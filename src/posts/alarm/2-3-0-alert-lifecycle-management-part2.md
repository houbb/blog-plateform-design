---
title: å‘Šè­¦çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆPart 2ï¼šé€šçŸ¥ä¸å“åº”ï¼‰â€”â€”æ„å»ºé«˜æ•ˆçš„å‘Šè­¦å“åº”ä½“ç³»
date: 2025-08-30
categories: [Alarm]
tags: [alarm]
published: true
---

å‘Šè­¦çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†æ˜¯æ™ºèƒ½æŠ¥è­¦å¹³å°çš„æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€ï¼Œæ¶µç›–äº†ä»å‘Šè­¦äº§ç”Ÿã€èšåˆã€å¤„ç†åˆ°æœ€ç»ˆè§£å†³çš„å®Œæ•´è¿‡ç¨‹ã€‚åœ¨å‰ä¸€ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬è¯¦ç»†æ¢è®¨äº†å‘Šè­¦ç”Ÿå‘½å‘¨æœŸçš„å‰åŠéƒ¨åˆ†â€”â€”å‘Šè­¦çš„äº§ç”Ÿä¸èšåˆã€‚æœ¬ç« å°†èšç„¦äºå‘Šè­¦ç”Ÿå‘½å‘¨æœŸçš„ååŠéƒ¨åˆ†ï¼šé€šçŸ¥ä¸å“åº”ï¼Œè¿™æ˜¯ç¡®ä¿å‘Šè­¦èƒ½å¤ŸåŠæ—¶ä¼ è¾¾ç»™ç›¸å…³äººå‘˜å¹¶å¾—åˆ°æœ‰æ•ˆå¤„ç†çš„å…³é”®ç¯èŠ‚ã€‚

<!-- more -->

## å¼•è¨€

åœ¨ç°ä»£å¤æ‚çš„ITç¯å¢ƒä¸­ï¼Œä»…ä»…èƒ½å¤Ÿå‡†ç¡®åœ°æ£€æµ‹å’Œèšåˆå‘Šè­¦æ˜¯è¿œè¿œä¸å¤Ÿçš„ã€‚ä¸€ä¸ªçœŸæ­£æœ‰æ•ˆçš„æŠ¥è­¦å¹³å°å¿…é¡»èƒ½å¤Ÿç¡®ä¿å‘Šè­¦ä¿¡æ¯åŠæ—¶ã€å‡†ç¡®åœ°ä¼ è¾¾ç»™åˆé€‚çš„äººå‘˜ï¼Œå¹¶æä¾›æœ‰æ•ˆçš„åä½œæœºåˆ¶æ¥ä¿ƒè¿›é—®é¢˜çš„å¿«é€Ÿè§£å†³ã€‚è¿™å°±æ˜¯å‘Šè­¦ç”Ÿå‘½å‘¨æœŸç®¡ç†ååŠéƒ¨åˆ†â€”â€”é€šçŸ¥ä¸å“åº”çš„é‡è¦æ€§æ‰€åœ¨ã€‚

å‘Šè­¦é€šçŸ¥ä¸å“åº”çš„ç›®æ ‡æ˜¯ï¼š
1. **ç²¾å‡†è§¦è¾¾**ï¼šç¡®ä¿å‘Šè­¦ä¿¡æ¯èƒ½å¤Ÿå‡†ç¡®ä¼ è¾¾ç»™ç›¸å…³è´£ä»»äºº
2. **åŠæ—¶å“åº”**ï¼šç¼©çŸ­ä»å‘Šè­¦äº§ç”Ÿåˆ°äººå‘˜å“åº”çš„æ—¶é—´
3. **æœ‰æ•ˆåä½œ**ï¼šæä¾›é«˜æ•ˆçš„åä½œå·¥å…·ä¿ƒè¿›é—®é¢˜è§£å†³
4. **é—­ç¯ç®¡ç†**ï¼šç¡®ä¿å‘Šè­¦å¾—åˆ°å¦¥å–„å¤„ç†å’Œè·Ÿè¸ª

## é€šçŸ¥ç­–ç•¥ç®¡ç†

### åˆ†çº§é€šçŸ¥æœºåˆ¶

#### é€šçŸ¥çº§åˆ«è®¾è®¡

ä¸€ä¸ªå®Œå–„çš„å‘Šè­¦é€šçŸ¥ç³»ç»Ÿéœ€è¦å»ºç«‹æ¸…æ™°çš„åˆ†çº§é€šçŸ¥æœºåˆ¶ï¼Œæ ¹æ®å‘Šè­¦çš„ä¸¥é‡æ€§ã€å½±å“èŒƒå›´å’Œç´§æ€¥ç¨‹åº¦æ¥ç¡®å®šé€šçŸ¥çš„ä¼˜å…ˆçº§å’Œæ–¹å¼ã€‚

```java
// å‘Šè­¦é€šçŸ¥çº§åˆ«æšä¸¾
public enum NotificationLevel {
    CRITICAL(4, "critical", "ä¸¥é‡", 0),      // ç«‹å³é€šçŸ¥ï¼Œæœ€é«˜ä¼˜å…ˆçº§
    HIGH(3, "high", "é«˜", 5),               // 5åˆ†é’Ÿå†…é€šçŸ¥
    MEDIUM(2, "medium", "ä¸­", 15),          // 15åˆ†é’Ÿå†…é€šçŸ¥
    LOW(1, "low", "ä½", 60);                // 1å°æ—¶å†…é€šçŸ¥
    
    private final int priority;
    private final String level;
    private final String displayName;
    private final int responseTimeMinutes;
    
    NotificationLevel(int priority, String level, String displayName, int responseTimeMinutes) {
        this.priority = priority;
        this.level = level;
        this.displayName = displayName;
        this.responseTimeMinutes = responseTimeMinutes;
    }
    
    public int getPriority() { return priority; }
    public String getLevel() { return level; }
    public String getDisplayName() { return displayName; }
    public int getResponseTimeMinutes() { return responseTimeMinutes; }
    
    public static NotificationLevel fromString(String level) {
        for (NotificationLevel nl : values()) {
            if (nl.level.equalsIgnoreCase(level)) {
                return nl;
            }
        }
        return MEDIUM; // é»˜è®¤çº§åˆ«
    }
}
```

#### é€šçŸ¥ç­–ç•¥é…ç½®

```java
// é€šçŸ¥ç­–ç•¥é…ç½®ç±»
public class NotificationStrategy {
    private String id;
    private String name;
    private String description;
    private NotificationLevel level;
    private List<NotificationChannel> channels;
    private EscalationPolicy escalationPolicy;
    private Map<String, Object> parameters;
    private boolean enabled;
    private String createdBy;
    private long createdAt;
    private long updatedAt;
    
    // é€šçŸ¥æ¸ é“å®šä¹‰
    public static class NotificationChannel {
        private ChannelType type;
        private String address;
        private int delaySeconds;
        private Map<String, Object> config;
        
        public enum ChannelType {
            EMAIL, SMS, PHONE, SLACK, WECHAT, DINGTALK, PAGERDUTY, CUSTOM
        }
        
        // getters and setters
    }
    
    // å‡çº§ç­–ç•¥å®šä¹‰
    public static class EscalationPolicy {
        private List<EscalationRule> rules;
        private int maxEscalationLevels;
        
        public static class EscalationRule {
            private int level;
            private List<String> recipients;
            private int timeoutMinutes;
            private List<NotificationChannel> channels;
            
            // getters and setters
        }
        
        // getters and setters
    }
    
    // getters and setters
}
```

### é€šçŸ¥æ¨¡æ¿ç®¡ç†

#### æ¨¡æ¿è®¾è®¡åŸåˆ™

ä¸€ä¸ªä¼˜ç§€çš„é€šçŸ¥æ¨¡æ¿åº”è¯¥å…·å¤‡ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **ä¿¡æ¯å®Œæ•´æ€§**ï¼šåŒ…å«å¿…è¦çš„å‘Šè­¦ä¿¡æ¯
2. **å¯è¯»æ€§å¼º**ï¼šæ ¼å¼æ¸…æ™°ï¼Œæ˜“äºç†è§£
3. **è¡ŒåŠ¨å¯¼å‘**ï¼šæä¾›æ˜ç¡®çš„è¡ŒåŠ¨æŒ‡å¯¼
4. **ä¸ªæ€§åŒ–**ï¼šæ”¯æŒå˜é‡æ›¿æ¢å’Œå®šåˆ¶

```java
// é€šçŸ¥æ¨¡æ¿ç®¡ç†å™¨
@Service
public class NotificationTemplateManager {
    private final Map<String, NotificationTemplate> templates = new ConcurrentHashMap<>();
    private final TemplateEngine templateEngine;
    
    public NotificationTemplateManager(TemplateEngine templateEngine) {
        this.templateEngine = templateEngine;
        initializeDefaultTemplates();
    }
    
    private void initializeDefaultTemplates() {
        // å…³é”®å‘Šè­¦æ¨¡æ¿
        NotificationTemplate criticalTemplate = new NotificationTemplate();
        criticalTemplate.setId("critical_alert");
        criticalTemplate.setName("å…³é”®å‘Šè­¦é€šçŸ¥æ¨¡æ¿");
        criticalTemplate.setSubject("[ä¸¥é‡å‘Šè­¦] {{alert.metricName}} å¼‚å¸¸");
        criticalTemplate.setContent(
            "=== å‘Šè­¦è¯¦æƒ… ===\n" +
            "å‘Šè­¦åç§°: {{alert.name}}\n" +
            "æŒ‡æ ‡åç§°: {{alert.metricName}}\n" +
            "å½“å‰å€¼: {{alert.value}}\n" +
            "é˜ˆå€¼: {{alert.threshold}}\n" +
            "ä¸¥é‡æ€§: {{alert.severity}}\n" +
            "å‘ç”Ÿæ—¶é—´: {{alert.timestamp | date:'yyyy-MM-dd HH:mm:ss'}}\n" +
            "æœåŠ¡: {{alert.labels.service}}\n" +
            "å®ä¾‹: {{alert.labels.instance}}\n\n" +
            "=== å¤„ç†å»ºè®® ===\n" +
            "1. ç«‹å³æ£€æŸ¥ç›¸å…³æœåŠ¡çŠ¶æ€\n" +
            "2. æŸ¥çœ‹è¯¦ç»†ç›‘æ§æ•°æ®: {{alert.dashboardUrl}}\n" +
            "3. å¦‚éœ€å¸®åŠ©ï¼Œè¯·è”ç³»: {{support.contact}}\n\n" +
            "=== å‘Šè­¦é“¾æ¥ ===\n" +
            "{{alert.alertUrl}}"
        );
        templates.put("critical_alert", criticalTemplate);
        
        // æ™®é€šå‘Šè­¦æ¨¡æ¿
        NotificationTemplate normalTemplate = new NotificationTemplate();
        normalTemplate.setId("normal_alert");
        normalTemplate.setName("æ™®é€šå‘Šè­¦é€šçŸ¥æ¨¡æ¿");
        normalTemplate.setSubject("[å‘Šè­¦] {{alert.metricName}} å¼‚å¸¸");
        normalTemplate.setContent(
            "å‘Šè­¦åç§°: {{alert.name}}\n" +
            "æŒ‡æ ‡åç§°: {{alert.metricName}}\n" +
            "å½“å‰å€¼: {{alert.value}}\n" +
            "ä¸¥é‡æ€§: {{alert.severity}}\n" +
            "æ—¶é—´: {{alert.timestamp | date:'yyyy-MM-dd HH:mm:ss'}}\n" +
            "æœåŠ¡: {{alert.labels.service}}\n\n" +
            "è¯¦æƒ…è¯·æŸ¥çœ‹: {{alert.alertUrl}}"
        );
        templates.put("normal_alert", normalTemplate);
    }
    
    public String renderTemplate(String templateId, Map<String, Object> variables) {
        NotificationTemplate template = templates.get(templateId);
        if (template == null) {
            throw new IllegalArgumentException("Template not found: " + templateId);
        }
        
        try {
            return templateEngine.process(template.getContent(), variables);
        } catch (Exception e) {
            logger.error("Failed to render template: " + templateId, e);
            return "Failed to render notification template";
        }
    }
    
    public String renderSubject(String templateId, Map<String, Object> variables) {
        NotificationTemplate template = templates.get(templateId);
        if (template == null) {
            return "Alert Notification";
        }
        
        try {
            return templateEngine.process(template.getSubject(), variables);
        } catch (Exception e) {
            logger.error("Failed to render subject template: " + templateId, e);
            return "Alert Notification";
        }
    }
    
    public void addTemplate(NotificationTemplate template) {
        templates.put(template.getId(), template);
    }
    
    public void removeTemplate(String templateId) {
        templates.remove(templateId);
    }
    
    public List<NotificationTemplate> getAllTemplates() {
        return new ArrayList<>(templates.values());
    }
}
```

## å¤šé€šé“é€šçŸ¥è·¯ç”±

### é€šçŸ¥æ¸ é“é›†æˆ

#### é‚®ä»¶é€šçŸ¥

```java
// é‚®ä»¶é€šçŸ¥æœåŠ¡
@Component
public class EmailNotificationService implements NotificationChannelService {
    private final JavaMailSender mailSender;
    private final NotificationTemplateManager templateManager;
    
    public EmailNotificationService(JavaMailSender mailSender,
                                  NotificationTemplateManager templateManager) {
        this.mailSender = mailSender;
        this.templateManager = templateManager;
    }
    
    @Override
    public NotificationResult sendNotification(NotificationMessage message) {
        try {
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
            
            // è®¾ç½®æ”¶ä»¶äºº
            helper.setTo(message.getRecipients().toArray(new String[0]));
            
            // è®¾ç½®ä¸»é¢˜
            String subject = templateManager.renderSubject(
                message.getTemplateId(), message.getVariables());
            helper.setSubject(subject);
            
            // è®¾ç½®å†…å®¹
            String content = templateManager.renderTemplate(
                message.getTemplateId(), message.getVariables());
            helper.setText(content, true); // æ”¯æŒHTML
            
            // æ·»åŠ é™„ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
            if (message.getAttachments() != null) {
                for (Attachment attachment : message.getAttachments()) {
                    helper.addAttachment(attachment.getFilename(), 
                                       attachment.getInputStream());
                }
            }
            
            // å‘é€é‚®ä»¶
            mailSender.send(mimeMessage);
            
            return NotificationResult.success();
        } catch (Exception e) {
            logger.error("Failed to send email notification", e);
            return NotificationResult.failure("Failed to send email: " + e.getMessage());
        }
    }
    
    @Override
    public boolean isAvailable() {
        // æ£€æŸ¥é‚®ä»¶æœåŠ¡æ˜¯å¦å¯ç”¨
        try {
            mailSender.testConnection();
            return true;
        } catch (Exception e) {
            logger.warn("Email service is not available", e);
            return false;
        }
    }
    
    @Override
    public ChannelType getChannelType() {
        return ChannelType.EMAIL;
    }
}
```

#### çŸ­ä¿¡é€šçŸ¥

```java
// çŸ­ä¿¡é€šçŸ¥æœåŠ¡
@Component
public class SmsNotificationService implements NotificationChannelService {
    private final SmsServiceClient smsClient;
    private final NotificationTemplateManager templateManager;
    
    public SmsNotificationService(SmsServiceClient smsClient,
                                NotificationTemplateManager templateManager) {
        this.smsClient = smsClient;
        this.templateManager = templateManager;
    }
    
    @Override
    public NotificationResult sendNotification(NotificationMessage message) {
        try {
            // æ¸²æŸ“çŸ­ä¿¡å†…å®¹ï¼ˆéœ€è¦ç®€æ´ï¼‰
            String content = templateManager.renderTemplate(
                message.getTemplateId() + "_sms", message.getVariables());
            
            // å¦‚æœæ²¡æœ‰ä¸“é—¨çš„çŸ­ä¿¡æ¨¡æ¿ï¼Œä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬
            if (content.equals("Failed to render notification template")) {
                content = createSimplifiedContent(message);
            }
            
            // å‘é€çŸ­ä¿¡
            for (String phoneNumber : message.getRecipients()) {
                SmsSendResult result = smsClient.sendSms(phoneNumber, content);
                if (!result.isSuccess()) {
                    return NotificationResult.failure(
                        "Failed to send SMS to " + phoneNumber + ": " + result.getErrorMessage());
                }
            }
            
            return NotificationResult.success();
        } catch (Exception e) {
            logger.error("Failed to send SMS notification", e);
            return NotificationResult.failure("Failed to send SMS: " + e.getMessage());
        }
    }
    
    private String createSimplifiedContent(NotificationMessage message) {
        // åˆ›å»ºç®€åŒ–çš„çŸ­ä¿¡å†…å®¹
        Alert alert = (Alert) message.getVariables().get("alert");
        if (alert != null) {
            return String.format("[%s] %s: %.2f (>%s) at %s", 
                alert.getSeverity().toUpperCase(),
                alert.getMetricName(),
                alert.getValue(),
                alert.getThreshold(),
                new SimpleDateFormat("HH:mm").format(new Date(alert.getTimestamp())));
        }
        return "Alert notification";
    }
    
    @Override
    public boolean isAvailable() {
        // æ£€æŸ¥çŸ­ä¿¡æœåŠ¡æ˜¯å¦å¯ç”¨
        return smsClient.isServiceAvailable();
    }
    
    @Override
    public ChannelType getChannelType() {
        return ChannelType.SMS;
    }
}
```

#### å³æ—¶é€šè®¯é€šçŸ¥

```java
// é’‰é’‰é€šçŸ¥æœåŠ¡
@Component
public class DingtalkNotificationService implements NotificationChannelService {
    private final DingtalkApiClient apiClient;
    private final NotificationTemplateManager templateManager;
    
    public DingtalkNotificationService(DingtalkApiClient apiClient,
                                     NotificationTemplateManager templateManager) {
        this.apiClient = apiClient;
        this.templateManager = templateManager;
    }
    
    @Override
    public NotificationResult sendNotification(NotificationMessage message) {
        try {
            // æ¸²æŸ“é’‰é’‰æ¶ˆæ¯å†…å®¹
            String content = templateManager.renderTemplate(
                message.getTemplateId() + "_dingtalk", message.getVariables());
            
            // å¦‚æœæ²¡æœ‰ä¸“é—¨çš„é’‰é’‰æ¨¡æ¿ï¼Œä½¿ç”¨é€šç”¨æ ¼å¼
            if (content.equals("Failed to render notification template")) {
                content = createDingtalkContent(message);
            }
            
            // å‘é€é’‰é’‰æ¶ˆæ¯
            DingtalkMessage dingtalkMessage = new DingtalkMessage();
            dingtalkMessage.setMsgtype("text");
            dingtalkMessage.setText(new DingtalkMessage.Text(content));
            
            for (String webhook : message.getRecipients()) {
                DingtalkSendResult result = apiClient.sendMessage(webhook, dingtalkMessage);
                if (!result.isSuccess()) {
                    return NotificationResult.failure(
                        "Failed to send Dingtalk message: " + result.getErrorMessage());
                }
            }
            
            return NotificationResult.success();
        } catch (Exception e) {
            logger.error("Failed to send Dingtalk notification", e);
            return NotificationResult.failure("Failed to send Dingtalk message: " + e.getMessage());
        }
    }
    
    private String createDingtalkContent(NotificationMessage message) {
        // åˆ›å»ºé’‰é’‰æ¶ˆæ¯å†…å®¹
        StringBuilder content = new StringBuilder();
        content.append("## å‘Šè­¦é€šçŸ¥\n\n");
        
        Alert alert = (Alert) message.getVariables().get("alert");
        if (alert != null) {
            content.append(String.format("**å‘Šè­¦åç§°**: %s\n", alert.getName()));
            content.append(String.format("**æŒ‡æ ‡åç§°**: %s\n", alert.getMetricName()));
            content.append(String.format("**å½“å‰å€¼**: %.2f\n", alert.getValue()));
            content.append(String.format("**ä¸¥é‡æ€§**: %s\n", alert.getSeverity()));
            content.append(String.format("**æ—¶é—´**: %s\n", 
                new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date(alert.getTimestamp()))));
        }
        
        return content.toString();
    }
    
    @Override
    public boolean isAvailable() {
        // é’‰é’‰æœåŠ¡é€šå¸¸æ€»æ˜¯å¯ç”¨çš„
        return true;
    }
    
    @Override
    public ChannelType getChannelType() {
        return ChannelType.DINGTALK;
    }
}
```

### æ™ºèƒ½è·¯ç”±ç­–ç•¥

```java
// æ™ºèƒ½é€šçŸ¥è·¯ç”±å™¨
@Service
public class SmartNotificationRouter {
    private final Map<ChannelType, NotificationChannelService> channelServices;
    private final RecipientResolver recipientResolver;
    private final NotificationHistoryService historyService;
    
    public SmartNotificationRouter(
            List<NotificationChannelService> channelServices,
            RecipientResolver recipientResolver,
            NotificationHistoryService historyService) {
        this.channelServices = new HashMap<>();
        for (NotificationChannelService service : channelServices) {
            this.channelServices.put(service.getChannelType(), service);
        }
        this.recipientResolver = recipientResolver;
        this.historyService = historyService;
    }
    
    public NotificationResult routeNotification(AlertEvent event) {
        try {
            // è§£ææ¥æ”¶è€…
            List<Recipient> recipients = recipientResolver.resolveRecipients(event);
            if (recipients.isEmpty()) {
                return NotificationResult.failure("No recipients found");
            }
            
            // è·å–é€šçŸ¥ç­–ç•¥
            NotificationStrategy strategy = getNotificationStrategy(event);
            
            // ä¸ºæ¯ä¸ªæ¥æ”¶è€…å‘é€é€šçŸ¥
            List<NotificationResult> results = new ArrayList<>();
            for (Recipient recipient : recipients) {
                NotificationResult result = sendToRecipient(event, recipient, strategy);
                results.add(result);
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æˆåŠŸçš„é€šçŸ¥
            boolean hasSuccess = results.stream().anyMatch(NotificationResult::isSuccess);
            if (hasSuccess) {
                return NotificationResult.success();
            } else {
                return NotificationResult.failure("All notifications failed");
            }
        } catch (Exception e) {
            logger.error("Failed to route notification for event: " + event.getId(), e);
            return NotificationResult.failure("Failed to route notification: " + e.getMessage());
        }
    }
    
    private NotificationResult sendToRecipient(AlertEvent event, 
                                            Recipient recipient,
                                            NotificationStrategy strategy) {
        // è·å–æ¥æ”¶è€…çš„é¦–é€‰é€šçŸ¥æ¸ é“
        List<ChannelType> preferredChannels = recipient.getPreferredChannels();
        
        // æŒ‰ä¼˜å…ˆçº§å°è¯•å‘é€é€šçŸ¥
        for (ChannelType channelType : preferredChannels) {
            NotificationChannelService channelService = channelServices.get(channelType);
            if (channelService != null && channelService.isAvailable()) {
                try {
                    // æ„å»ºé€šçŸ¥æ¶ˆæ¯
                    NotificationMessage message = buildNotificationMessage(
                        event, recipient, channelType, strategy);
                    
                    // å‘é€é€šçŸ¥
                    NotificationResult result = channelService.sendNotification(message);
                    
                    if (result.isSuccess()) {
                        // è®°å½•æˆåŠŸçš„é€šçŸ¥
                        historyService.recordSuccessfulNotification(
                            event.getId(), recipient.getId(), channelType);
                        return result;
                    } else {
                        // è®°å½•å¤±è´¥çš„é€šçŸ¥
                        historyService.recordFailedNotification(
                            event.getId(), recipient.getId(), channelType, result.getErrorMessage());
                    }
                } catch (Exception e) {
                    logger.error("Exception occurred while sending notification via " + 
                               channelType + " to " + recipient.getId(), e);
                    historyService.recordFailedNotification(
                        event.getId(), recipient.getId(), channelType, e.getMessage());
                }
            }
        }
        
        return NotificationResult.failure("All preferred channels failed");
    }
    
    private NotificationMessage buildNotificationMessage(AlertEvent event,
                                                       Recipient recipient,
                                                       ChannelType channelType,
                                                       NotificationStrategy strategy) {
        NotificationMessage message = new NotificationMessage();
        message.setEventId(event.getId());
        message.setRecipientId(recipient.getId());
        message.setChannelType(channelType);
        message.setPriority(strategy.getLevel().getPriority());
        message.setTemplateId(getTemplateId(event, channelType));
        
        // æ„å»ºæ¨¡æ¿å˜é‡
        Map<String, Object> variables = new HashMap<>();
        variables.put("event", event);
        variables.put("recipient", recipient);
        variables.put("timestamp", System.currentTimeMillis());
        variables.put("severityText", getSeverityText(event.getSeverity()));
        message.setVariables(variables);
        
        // è®¾ç½®æ¥æ”¶è€…
        List<String> addresses = recipient.getAddresses(channelType);
        message.setRecipients(addresses);
        
        return message;
    }
    
    private String getTemplateId(AlertEvent event, ChannelType channelType) {
        // æ ¹æ®å‘Šè­¦ä¸¥é‡æ€§å’Œæ¸ é“ç±»å‹é€‰æ‹©æ¨¡æ¿
        String baseTemplate = event.getSeverity().toLowerCase();
        switch (channelType) {
            case SMS:
                return baseTemplate + "_sms";
            case DINGTALK:
                return baseTemplate + "_dingtalk";
            case WECHAT:
                return baseTemplate + "_wechat";
            default:
                return baseTemplate + "_alert";
        }
    }
    
    private String getSeverityText(String severity) {
        switch (severity.toLowerCase()) {
            case "critical": return "ä¸¥é‡";
            case "high": return "é«˜";
            case "medium": return "ä¸­";
            case "low": return "ä½";
            default: return severity;
        }
    }
    
    private NotificationStrategy getNotificationStrategy(AlertEvent event) {
        // æ ¹æ®å‘Šè­¦äº‹ä»¶è·å–é€šçŸ¥ç­–ç•¥
        // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦ä»é…ç½®æˆ–æ•°æ®åº“è·å–
        NotificationStrategy strategy = new NotificationStrategy();
        strategy.setLevel(NotificationLevel.fromString(event.getSeverity()));
        
        List<NotificationChannel> channels = new ArrayList<>();
        NotificationChannel emailChannel = new NotificationChannel();
        emailChannel.setType(ChannelType.EMAIL);
        channels.add(emailChannel);
        
        NotificationChannel smsChannel = new NotificationChannel();
        smsChannel.setType(ChannelType.SMS);
        channels.add(smsChannel);
        
        strategy.setChannels(channels);
        
        return strategy;
    }
}
```

## å€¼ç­ç®¡ç†ä¸æ’ç­

### æ’ç­ç³»ç»Ÿè®¾è®¡

#### å€¼ç­å›¢é˜Ÿç®¡ç†

```java
// å€¼ç­å›¢é˜Ÿç®¡ç†å™¨
@Service
public class OnCallTeamManager {
    private final Map<String, OnCallTeam> teams = new ConcurrentHashMap<>();
    
    public void addTeam(OnCallTeam team) {
        teams.put(team.getId(), team);
    }
    
    public void removeTeam(String teamId) {
        teams.remove(teamId);
    }
    
    public OnCallTeam getTeam(String teamId) {
        return teams.get(teamId);
    }
    
    public List<OnCallTeam> getAllTeams() {
        return new ArrayList<>(teams.values());
    }
    
    public List<OnCallMember> getOnCallMembers(String teamId, long timestamp) {
        OnCallTeam team = teams.get(teamId);
        if (team == null) {
            return Collections.emptyList();
        }
        
        return team.getOnCallMembers(timestamp);
    }
    
    public List<OnCallMember> getOnCallMembersForService(String service, long timestamp) {
        return teams.values().stream()
            .filter(team -> team.getCoveredServices().contains(service))
            .flatMap(team -> team.getOnCallMembers(timestamp).stream())
            .distinct()
            .collect(Collectors.toList());
    }
}

// å€¼ç­å›¢é˜Ÿå®šä¹‰
public class OnCallTeam {
    private String id;
    private String name;
    private String description;
    private List<OnCallMember> members;
    private List<String> coveredServices;
    private List<OnCallSchedule> schedules;
    private boolean enabled;
    
    public List<OnCallMember> getOnCallMembers(long timestamp) {
        return schedules.stream()
            .filter(schedule -> schedule.isInSchedule(timestamp))
            .flatMap(schedule -> schedule.getOnCallMembers().stream())
            .distinct()
            .collect(Collectors.toList());
    }
    
    // getters and setters
}

// å€¼ç­æˆå‘˜å®šä¹‰
public class OnCallMember {
    private String id;
    private String name;
    private String email;
    private String phoneNumber;
    private String slackId;
    private String dingtalkId;
    private List<String> skills;
    private boolean active;
    
    // getters and setters
}

// å€¼ç­è®¡åˆ’å®šä¹‰
public class OnCallSchedule {
    private String id;
    private String name;
    private ScheduleType type;
    private List<ScheduleEntry> entries;
    private List<OnCallMember> members;
    private String timezone;
    
    public enum ScheduleType {
        ROTATION, FIXED, ESCALATION
    }
    
    public boolean isInSchedule(long timestamp) {
        // æ£€æŸ¥æ—¶é—´æˆ³æ˜¯å¦åœ¨è®¡åˆ’èŒƒå›´å†…
        return entries.stream().anyMatch(entry -> entry.containsTime(timestamp));
    }
    
    public List<OnCallMember> getOnCallMembers() {
        return new ArrayList<>(members);
    }
    
    // getters and setters
}

// æ’ç­æ¡ç›®å®šä¹‰
public class ScheduleEntry {
    private long startTime;
    private long endTime;
    private List<String> memberIds;
    private String description;
    
    public boolean containsTime(long timestamp) {
        return timestamp >= startTime && timestamp <= endTime;
    }
    
    // getters and setters
}
```

#### åŠ¨æ€æ’ç­è°ƒæ•´

```java
// åŠ¨æ€æ’ç­è°ƒæ•´å™¨
@Service
public class DynamicScheduleAdjuster {
    private final OnCallTeamManager teamManager;
    private final AlertHistoryService alertHistoryService;
    private final ScheduledExecutorService adjustmentExecutor;
    
    public DynamicScheduleAdjuster(OnCallTeamManager teamManager,
                                 AlertHistoryService alertHistoryService) {
        this.teamManager = teamManager;
        this.alertHistoryService = alertHistoryService;
        this.adjustmentExecutor = Executors.newScheduledThreadPool(1);
        
        // å®šæœŸæ£€æŸ¥å’Œè°ƒæ•´æ’ç­
        adjustmentExecutor.scheduleAtFixedRate(this::checkAndAdjustSchedules,
                                             3600, 3600, TimeUnit.SECONDS); // æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡
    }
    
    public void checkAndAdjustSchedules() {
        try {
            long currentTime = System.currentTimeMillis();
            long oneDayAgo = currentTime - 24 * 60 * 60 * 1000;
            
            // è·å–æ‰€æœ‰å›¢é˜Ÿ
            List<OnCallTeam> teams = teamManager.getAllTeams();
            
            for (OnCallTeam team : teams) {
                // åˆ†æè¿‡å»24å°æ—¶çš„å‘Šè­¦æƒ…å†µ
                AlertAnalysisResult analysis = analyzeAlerts(team, oneDayAgo, currentTime);
                
                // æ ¹æ®åˆ†æç»“æœè°ƒæ•´æ’ç­
                if (analysis.getAlertCount() > 50) { // å‘Šè­¦è¿‡å¤š
                    adjustForHighAlertVolume(team, analysis);
                } else if (analysis.getAverageResponseTime() > 300000) { // å“åº”æ—¶é—´è¿‡é•¿
                    adjustForSlowResponse(team, analysis);
                }
            }
        } catch (Exception e) {
            logger.error("Failed to check and adjust schedules", e);
        }
    }
    
    private AlertAnalysisResult analyzeAlerts(OnCallTeam team, long startTime, long endTime) {
        // åˆ†æå›¢é˜Ÿè´Ÿè´£æœåŠ¡çš„å‘Šè­¦æƒ…å†µ
        AlertAnalysisResult result = new AlertAnalysisResult();
        
        List<String> services = team.getCoveredServices();
        int totalAlerts = 0;
        long totalResponseTime = 0;
        int resolvedAlerts = 0;
        
        for (String service : services) {
            List<AlertEvent> alerts = alertHistoryService.getAlertsByService(
                service, startTime, endTime);
            
            totalAlerts += alerts.size();
            
            for (AlertEvent alert : alerts) {
                if (alert.getResolvedTime() > 0) {
                    totalResponseTime += (alert.getResolvedTime() - alert.getTimestamp());
                    resolvedAlerts++;
                }
            }
        }
        
        result.setAlertCount(totalAlerts);
        result.setAverageResponseTime(resolvedAlerts > 0 ? 
            totalResponseTime / resolvedAlerts : 0);
            
        return result;
    }
    
    private void adjustForHighAlertVolume(OnCallTeam team, AlertAnalysisResult analysis) {
        // å‘Šè­¦é‡è¿‡é«˜æ—¶çš„è°ƒæ•´ç­–ç•¥
        logger.info("Adjusting schedule for team {} due to high alert volume: {}", 
                   team.getName(), analysis.getAlertCount());
        
        // å¯ä»¥é‡‡å–çš„æªæ–½ï¼š
        // 1. å¢åŠ å€¼ç­äººå‘˜
        // 2. ç¼©çŸ­è½®ç­å‘¨æœŸ
        // 3. è°ƒæ•´æŠ€èƒ½åŒ¹é…
        // 4. å‘é€æé†’é€šçŸ¥
    }
    
    private void adjustForSlowResponse(OnCallTeam team, AlertAnalysisResult analysis) {
        // å“åº”æ—¶é—´è¿‡é•¿æ—¶çš„è°ƒæ•´ç­–ç•¥
        logger.info("Adjusting schedule for team {} due to slow response time: {}ms", 
                   team.getName(), analysis.getAverageResponseTime());
        
        // å¯ä»¥é‡‡å–çš„æªæ–½ï¼š
        // 1. è°ƒæ•´äººå‘˜æŠ€èƒ½åˆ†é…
        // 2. ä¼˜åŒ–é€šçŸ¥æ¸ é“
        // 3. è°ƒæ•´å‡çº§ç­–ç•¥
    }
    
    // å‘Šè­¦åˆ†æç»“æœ
    private static class AlertAnalysisResult {
        private int alertCount;
        private long averageResponseTime;
        
        // getters and setters
        public int getAlertCount() { return alertCount; }
        public void setAlertCount(int alertCount) { this.alertCount = alertCount; }
        public long getAverageResponseTime() { return averageResponseTime; }
        public void setAverageResponseTime(long averageResponseTime) { this.averageResponseTime = averageResponseTime; }
    }
}
```

## å“åº”åä½œæœºåˆ¶

### å‘Šè­¦ç¾¤èŠè‡ªåŠ¨åˆ›å»º

```java
// å‘Šè­¦åä½œç®¡ç†å™¨
@Service
public class AlertCollaborationManager {
    private final ChatServiceClient chatServiceClient;
    private final OnCallTeamManager teamManager;
    private final Map<String, String> alertChatRooms = new ConcurrentHashMap<>();
    
    public AlertCollaborationManager(ChatServiceClient chatServiceClient,
                                   OnCallTeamManager teamManager) {
        this.chatServiceClient = chatServiceClient;
        this.teamManager = teamManager;
    }
    
    public String createAlertChatRoom(AlertEvent event) {
        String alertId = event.getId();
        
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨èŠå¤©å®¤
        String existingRoomId = alertChatRooms.get(alertId);
        if (existingRoomId != null) {
            return existingRoomId;
        }
        
        try {
            // åˆ›å»ºèŠå¤©å®¤
            ChatRoom chatRoom = new ChatRoom();
            chatRoom.setName(String.format("å‘Šè­¦-%s-%s", 
                event.getMetricName(), 
                new SimpleDateFormat("MM-dd HH:mm").format(new Date(event.getTimestamp()))));
            chatRoom.setDescription(createAlertDescription(event));
            
            // æ·»åŠ ç›¸å…³äººå‘˜
            List<String> memberIds = getAlertParticipants(event);
            chatRoom.setMemberIds(memberIds);
            
            // åˆ›å»ºèŠå¤©å®¤
            String roomId = chatServiceClient.createRoom(chatRoom);
            
            // ä¿å­˜èŠå¤©å®¤ä¿¡æ¯
            alertChatRooms.put(alertId, roomId);
            
            // å‘é€åˆå§‹æ¶ˆæ¯
            sendInitialAlertMessage(roomId, event);
            
            return roomId;
        } catch (Exception e) {
            logger.error("Failed to create alert chat room for event: " + alertId, e);
            return null;
        }
    }
    
    private String createAlertDescription(AlertEvent event) {
        return String.format("%s å‘Šè­¦ï¼Œå€¼: %.2fï¼Œä¸¥é‡æ€§: %sï¼ŒæœåŠ¡: %s", 
            event.getMetricName(), event.getValue(), event.getSeverity(), 
            event.getLabels().getOrDefault("service", "unknown"));
    }
    
    private List<String> getAlertParticipants(AlertEvent event) {
        List<String> participants = new ArrayList<>();
        
        // æ·»åŠ å€¼ç­äººå‘˜
        String service = event.getLabels().get("service");
        if (service != null) {
            List<OnCallMember> onCallMembers = teamManager.getOnCallMembersForService(
                service, System.currentTimeMillis());
            participants.addAll(onCallMembers.stream()
                .map(OnCallMember::getSlackId) // å‡è®¾ä½¿ç”¨Slack ID
                .filter(Objects::nonNull)
                .collect(Collectors.toList()));
        }
        
        // æ·»åŠ å‘Šè­¦åˆ›å»ºè€…ï¼ˆå¦‚æœæœ‰ï¼‰
        String creator = event.getCreatedBy();
        if (creator != null && !participants.contains(creator)) {
            participants.add(creator);
        }
        
        return participants;
    }
    
    private void sendInitialAlertMessage(String roomId, AlertEvent event) {
        try {
            ChatMessage message = new ChatMessage();
            message.setRoomId(roomId);
            message.setText(createAlertMessageText(event));
            message.setAttachments(createAlertMessageAttachments(event));
            
            chatServiceClient.sendMessage(message);
        } catch (Exception e) {
            logger.error("Failed to send initial alert message to room: " + roomId, e);
        }
    }
    
    private String createAlertMessageText(AlertEvent event) {
        return String.format(
            "ğŸš¨ **æ–°å‘Šè­¦**\n\n" +
            "**æŒ‡æ ‡**: %s\n" +
            "**å½“å‰å€¼**: %.2f\n" +
            "**é˜ˆå€¼**: %s\n" +
            "**ä¸¥é‡æ€§**: %s\n" +
            "**æ—¶é—´**: %s\n" +
            "**æœåŠ¡**: %s\n" +
            "**å®ä¾‹**: %s\n\n" +
            "è¯·ç›¸å…³äººå‘˜åŠæ—¶å¤„ç†ï¼",
            event.getMetricName(),
            event.getValue(),
            event.getThreshold(),
            event.getSeverity(),
            new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date(event.getTimestamp())),
            event.getLabels().getOrDefault("service", "unknown"),
            event.getLabels().getOrDefault("instance", "unknown")
        );
    }
    
    private List<ChatMessage.Attachment> createAlertMessageAttachments(AlertEvent event) {
        List<ChatMessage.Attachment> attachments = new ArrayList<>();
        
        // æ·»åŠ æ“ä½œæŒ‰é’®
        ChatMessage.Attachment actionAttachment = new ChatMessage.Attachment();
        actionAttachment.setText("æ“ä½œé€‰é¡¹");
        
        List<ChatMessage.Attachment.Action> actions = new ArrayList<>();
        
        ChatMessage.Attachment.Action acknowledgeAction = new ChatMessage.Attachment.Action();
        acknowledgeAction.setName("acknowledge");
        acknowledgeAction.setText("ç¡®è®¤å‘Šè­¦");
        acknowledgeAction.setType("button");
        acknowledgeAction.setValue("ack_" + event.getId());
        actions.add(acknowledgeAction);
        
        ChatMessage.Attachment.Action resolveAction = new ChatMessage.Attachment.Action();
        resolveAction.setName("resolve");
        resolveAction.setText("æ ‡è®°è§£å†³");
        resolveAction.setType("button");
        resolveAction.setValue("resolve_" + event.getId());
        actions.add(resolveAction);
        
        actionAttachment.setActions(actions);
        attachments.add(actionAttachment);
        
        // æ·»åŠ é“¾æ¥é™„ä»¶
        ChatMessage.Attachment linkAttachment = new ChatMessage.Attachment();
        linkAttachment.setText("ç›¸å…³é“¾æ¥");
        
        List<ChatMessage.Attachment.Field> fields = new ArrayList<>();
        
        ChatMessage.Attachment.Field dashboardField = new ChatMessage.Attachment.Field();
        dashboardField.setTitle("ç›‘æ§é¢æ¿");
        dashboardField.setValue("[æŸ¥çœ‹è¯¦ç»†æ•°æ®](" + event.getDashboardUrl() + ")");
        dashboardField.setShort(true);
        fields.add(dashboardField);
        
        ChatMessage.Attachment.Field alertField = new ChatMessage.Attachment.Field();
        alertField.setTitle("å‘Šè­¦è¯¦æƒ…");
        alertField.setValue("[æŸ¥çœ‹å‘Šè­¦](" + event.getAlertUrl() + ")");
        alertField.setShort(true);
        fields.add(alertField);
        
        linkAttachment.setFields(fields);
        attachments.add(linkAttachment);
        
        return attachments;
    }
    
    public void addParticipantToAlertChat(String alertId, String participantId) {
        String roomId = alertChatRooms.get(alertId);
        if (roomId != null) {
            try {
                chatServiceClient.addMemberToRoom(roomId, participantId);
            } catch (Exception e) {
                logger.error("Failed to add participant to alert chat: " + roomId, e);
            }
        }
    }
    
    public void sendUpdateMessage(String alertId, String message) {
        String roomId = alertChatRooms.get(alertId);
        if (roomId != null) {
            try {
                ChatMessage chatMessage = new ChatMessage();
                chatMessage.setRoomId(roomId);
                chatMessage.setText(message);
                chatServiceClient.sendMessage(chatMessage);
            } catch (Exception e) {
                logger.error("Failed to send update message to room: " + roomId, e);
            }
        }
    }
}
```

### å¿«é€Ÿæ²Ÿé€šæœºåˆ¶

```java
// å¿«é€Ÿæ²Ÿé€šåè°ƒå™¨
@Service
public class RapidCommunicationCoordinator {
    private final AlertCollaborationManager collaborationManager;
    private final NotificationService notificationService;
    private final Map<String, CommunicationContext> activeCommunications = new ConcurrentHashMap<>();
    
    public void initiateRapidCommunication(AlertEvent event, String initiator) {
        try {
            // åˆ›å»ºæ²Ÿé€šä¸Šä¸‹æ–‡
            CommunicationContext context = new CommunicationContext();
            context.setAlertId(event.getId());
            context.setInitiator(initiator);
            context.setStartTime(System.currentTimeMillis());
            context.setStatus(CommunicationStatus.ACTIVE);
            
            // åˆ›å»ºå‘Šè­¦èŠå¤©å®¤
            String roomId = collaborationManager.createAlertChatRoom(event);
            context.setChatRoomId(roomId);
            
            // ä¿å­˜æ²Ÿé€šä¸Šä¸‹æ–‡
            activeCommunications.put(event.getId(), context);
            
            // å‘é€ç´§æ€¥é€šçŸ¥ç»™ç›¸å…³äººå‘˜
            notifyKeyParticipants(event, initiator);
            
            // è®¾ç½®è¶…æ—¶æ£€æŸ¥
            scheduleTimeoutCheck(event.getId());
            
        } catch (Exception e) {
            logger.error("Failed to initiate rapid communication for alert: " + event.getId(), e);
        }
    }
    
    private void notifyKeyParticipants(AlertEvent event, String initiator) {
        // è·å–å…³é”®å‚ä¸äººå‘˜
        List<String> keyParticipants = getkeyParticipants(event);
        
        // å‘é€ç´§æ€¥é€šçŸ¥
        for (String participant : keyParticipants) {
            if (!participant.equals(initiator)) { // ä¸é€šçŸ¥å‘èµ·è€…è‡ªå·±
                sendUrgentNotification(participant, event);
            }
        }
    }
    
    private List<String> getkeyParticipants(AlertEvent event) {
        List<String> participants = new ArrayList<>();
        
        // æ·»åŠ å€¼ç­äººå‘˜
        String service = event.getLabels().get("service");
        if (service != null) {
            participants.addAll(getOnCallMembersForService(service));
        }
        
        // æ·»åŠ å›¢é˜Ÿè´Ÿè´£äºº
        participants.addAll(getTeamLeads());
        
        // æ·»åŠ ç³»ç»Ÿç®¡ç†å‘˜
        participants.addAll(getSystemAdmins());
        
        return participants.stream().distinct().collect(Collectors.toList());
    }
    
    private void sendUrgentNotification(String recipient, AlertEvent event) {
        try {
            UrgentNotification notification = new UrgentNotification();
            notification.setRecipient(recipient);
            notification.setTitle("ç´§æ€¥å‘Šè­¦å¤„ç†è¯·æ±‚");
            notification.setMessage(String.format(
                "æ”¶åˆ°ç´§æ€¥å‘Šè­¦ï¼š%s (ä¸¥é‡æ€§: %s)\n" +
                "è¯·ç«‹å³åŠ å…¥ç›¸å…³è®¨è®ºç»„è¿›è¡Œå¤„ç†ã€‚",
                event.getMetricName(), event.getSeverity()));
            notification.setAlertId(event.getId());
            notification.setUrgency(Urgency.HIGH);
            
            notificationService.sendUrgentNotification(notification);
        } catch (Exception e) {
            logger.error("Failed to send urgent notification to: " + recipient, e);
        }
    }
    
    private void scheduleTimeoutCheck(String alertId) {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        executor.schedule(() -> checkCommunicationTimeout(alertId), 
                         30, TimeUnit.MINUTES); // 30åˆ†é’Ÿåæ£€æŸ¥
    }
    
    private void checkCommunicationTimeout(String alertId) {
        CommunicationContext context = activeCommunications.get(alertId);
        if (context != null && context.getStatus() == CommunicationStatus.ACTIVE) {
            long currentTime = System.currentTimeMillis();
            if (currentTime - context.getStartTime() > 30 * 60 * 1000) { // è¶…è¿‡30åˆ†é’Ÿ
                // å‘é€è¶…æ—¶æé†’
                sendTimeoutReminder(alertId);
            }
        }
    }
    
    private void sendTimeoutReminder(String alertId) {
        // å‘é€è¶…æ—¶æé†’ç»™ç›¸å…³äººå‘˜
        logger.warn("Communication timeout for alert: " + alertId);
        // å®ç°æé†’é€»è¾‘
    }
    
    public void updateCommunicationStatus(String alertId, CommunicationStatus status) {
        CommunicationContext context = activeCommunications.get(alertId);
        if (context != null) {
            context.setStatus(status);
            context.setUpdateTime(System.currentTimeMillis());
            
            if (status == CommunicationStatus.RESOLVED) {
                // ç»“æŸæ²Ÿé€š
                endCommunication(alertId);
            }
        }
    }
    
    private void endCommunication(String alertId) {
        activeCommunications.remove(alertId);
        // å¯ä»¥å‘é€ç»“æŸé€šçŸ¥ç­‰
    }
    
    // æ²Ÿé€šä¸Šä¸‹æ–‡
    private static class CommunicationContext {
        private String alertId;
        private String initiator;
        private String chatRoomId;
        private CommunicationStatus status;
        private long startTime;
        private long updateTime;
        
        // getters and setters
    }
    
    // æ²Ÿé€šçŠ¶æ€æšä¸¾
    public enum CommunicationStatus {
        ACTIVE, IN_PROGRESS, RESOLVED, CANCELLED
    }
    
    // ç´§æ€¥ç¨‹åº¦æšä¸¾
    public enum Urgency {
        LOW, MEDIUM, HIGH, CRITICAL
    }
}
```

## æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§

### é€šçŸ¥æ€§èƒ½ä¼˜åŒ–

```java
// é€šçŸ¥æ€§èƒ½ä¼˜åŒ–å™¨
@Component
public class NotificationPerformanceOptimizer {
    private final MeterRegistry meterRegistry;
    private final Cache<String, NotificationMetrics> metricsCache;
    private final ScheduledExecutorService metricsExecutor;
    
    public NotificationPerformanceOptimizer(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.metricsCache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(1, TimeUnit.HOURS)
            .build();
        this.metricsExecutor = Executors.newScheduledThreadPool(1);
        
        // å®šæœŸæŠ¥å‘ŠæŒ‡æ ‡
        metricsExecutor.scheduleAtFixedRate(this::reportMetrics, 
                                          60, 60, TimeUnit.SECONDS);
    }
    
    public void recordNotificationAttempt(String channelId, long startTime) {
        long duration = System.currentTimeMillis() - startTime;
        
        // æ›´æ–°ç¼“å­˜ä¸­çš„æŒ‡æ ‡
        NotificationMetrics metrics = metricsCache.get(channelId, 
            k -> new NotificationMetrics());
        metrics.recordAttempt(duration);
        
        // è®°å½•åˆ°ç›‘æ§ç³»ç»Ÿ
        Timer.builder("notification.attempt.duration")
            .tag("channel", channelId)
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    public void recordNotificationSuccess(String channelId) {
        NotificationMetrics metrics = metricsCache.get(channelId, 
            k -> new NotificationMetrics());
        metrics.recordSuccess();
        
        Counter.builder("notification.success.count")
            .tag("channel", channelId)
            .register(meterRegistry)
            .increment();
    }
    
    public void recordNotificationFailure(String channelId, String errorType) {
        NotificationMetrics metrics = metricsCache.get(channelId, 
            k -> new NotificationMetrics());
        metrics.recordFailure();
        
        Counter.builder("notification.failure.count")
            .tag("channel", channelId)
            .tag("error", errorType)
            .register(meterRegistry)
            .increment();
    }
    
    private void reportMetrics() {
        // å®šæœŸæŠ¥å‘ŠèšåˆæŒ‡æ ‡
        for (Map.Entry<String, NotificationMetrics> entry : metricsCache.asMap().entrySet()) {
            String channelId = entry.getKey();
            NotificationMetrics metrics = entry.getValue();
            
            // æŠ¥å‘ŠæˆåŠŸç‡
            double successRate = metrics.getSuccessRate();
            Gauge.builder("notification.success.rate")
                .tag("channel", channelId)
                .register(meterRegistry, successRate);
                
            // æŠ¥å‘Šå¹³å‡è€—æ—¶
            double avgDuration = metrics.getAverageDuration();
            Gauge.builder("notification.average.duration")
                .tag("channel", channelId)
                .register(meterRegistry, avgDuration);
        }
    }
    
    // é€šçŸ¥æŒ‡æ ‡æ•°æ®ç±»
    private static class NotificationMetrics {
        private final AtomicLong totalAttempts = new AtomicLong(0);
        private final AtomicLong successfulAttempts = new AtomicLong(0);
        private final AtomicLong failedAttempts = new AtomicLong(0);
        private final AtomicLong totalDuration = new AtomicLong(0);
        
        public void recordAttempt(long duration) {
            totalAttempts.incrementAndGet();
            totalDuration.addAndGet(duration);
        }
        
        public void recordSuccess() {
            successfulAttempts.incrementAndGet();
        }
        
        public void recordFailure() {
            failedAttempts.incrementAndGet();
        }
        
        public double getSuccessRate() {
            long total = totalAttempts.get();
            return total > 0 ? (double) successfulAttempts.get() / total : 0.0;
        }
        
        public double getAverageDuration() {
            long total = totalAttempts.get();
            return total > 0 ? (double) totalDuration.get() / total : 0.0;
        }
    }
}
```

### æ‰¹é‡é€šçŸ¥å¤„ç†

```java
// æ‰¹é‡é€šçŸ¥å¤„ç†å™¨
@Service
public class BatchNotificationProcessor {
    private final SmartNotificationRouter notificationRouter;
    private final NotificationPerformanceOptimizer performanceOptimizer;
    private final ExecutorService executorService;
    private final int batchSize;
    private final long batchTimeoutMs;
    
    public BatchNotificationProcessor(SmartNotificationRouter notificationRouter,
                                    NotificationPerformanceOptimizer performanceOptimizer,
                                    @Value("${notification.batch.size:100}") int batchSize,
                                    @Value("${notification.batch.timeout.ms:5000}") long batchTimeoutMs) {
        this.notificationRouter = notificationRouter;
        this.performanceOptimizer = performanceOptimizer;
        this.batchSize = batchSize;
        this.batchTimeoutMs = batchTimeoutMs;
        this.executorService = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors() * 2);
    }
    
    public CompletableFuture<List<NotificationResult>> processNotifications(
            List<AlertEvent> events) {
        
        // åˆ†æ‰¹å¤„ç†
        List<List<AlertEvent>> batches = partition(events, batchSize);
        
        List<CompletableFuture<List<NotificationResult>>> batchFutures = new ArrayList<>();
        
        for (List<AlertEvent> batch : batches) {
            CompletableFuture<List<NotificationResult>> batchFuture = 
                CompletableFuture.supplyAsync(() -> processBatch(batch), executorService);
            batchFutures.add(batchFuture);
        }
        
        // åˆå¹¶æ‰€æœ‰æ‰¹æ¬¡çš„ç»“æœ
        return CompletableFuture.allOf(batchFutures.toArray(new CompletableFuture[0]))
            .thenApply(v -> batchFutures.stream()
                .map(CompletableFuture::join)
                .flatMap(List::stream)
                .collect(Collectors.toList()));
    }
    
    private List<NotificationResult> processBatch(List<AlertEvent> batch) {
        List<NotificationResult> results = new ArrayList<>();
        
        for (AlertEvent event : batch) {
            long startTime = System.currentTimeMillis();
            String channelId = "batch_" + event.getId();
            
            try {
                NotificationResult result = notificationRouter.routeNotification(event);
                results.add(result);
                
                performanceOptimizer.recordNotificationAttempt(channelId, startTime);
                
                if (result.isSuccess()) {
                    performanceOptimizer.recordNotificationSuccess(channelId);
                } else {
                    performanceOptimizer.recordNotificationFailure(channelId, "routing_failed");
                }
            } catch (Exception e) {
                logger.error("Failed to process notification for event: " + event.getId(), e);
                results.add(NotificationResult.failure(e.getMessage()));
                performanceOptimizer.recordNotificationFailure(channelId, "exception");
            }
        }
        
        return results;
    }
    
    private <T> List<List<T>> partition(List<T> list, int size) {
        List<List<T>> partitions = new ArrayList<>();
        for (int i = 0; i < list.size(); i += size) {
            partitions.add(list.subList(i, Math.min(i + size, list.size())));
        }
        return partitions;
    }
}
```

## æœ€ä½³å®è·µä¸æ€»ç»“

### é…ç½®ç®¡ç†

```yaml
# é€šçŸ¥ä¸å“åº”é…ç½®ç¤ºä¾‹
notification:
  enabled: true
  batch:
    size: 100
    timeout.ms: 5000
  channels:
    email:
      enabled: true
      smtp:
        host: smtp.company.com
        port: 587
        username: alert@company.com
        password: ${EMAIL_PASSWORD}
    sms:
      enabled: true
      provider: twilio
      account_sid: ${TWILIO_ACCOUNT_SID}
      auth_token: ${TWILIO_AUTH_TOKEN}
    dingtalk:
      enabled: true
      webhook_url: ${DINGTALK_WEBHOOK_URL}
  strategy:
    critical:
      channels: [sms, phone, email, dingtalk]
      escalation:
        level1:
          timeout: 5
          channels: [sms, phone]
        level2:
          timeout: 10
          channels: [email, dingtalk]
        level3:
          timeout: 30
          channels: [phone_call_to_manager]
  performance:
    cache:
      size: 1000
      ttl.minutes: 60
    thread.pool:
      size: 20
  collaboration:
    chat:
      enabled: true
      provider: slack
      webhook_url: ${SLACK_WEBHOOK_URL}
    rapid_communication:
      enabled: true
      timeout.minutes: 30
```

### ç›‘æ§å‘Šè­¦

```java
// é€šçŸ¥ç³»ç»Ÿå¥åº·æ£€æŸ¥
@Component
public class NotificationHealthChecker {
    private final Map<ChannelType, NotificationChannelService> channelServices;
    private final MeterRegistry meterRegistry;
    
    @Scheduled(fixedRate = 300000) // æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    public void checkHealth() {
        for (Map.Entry<ChannelType, NotificationChannelService> entry : channelServices.entrySet()) {
            ChannelType channelType = entry.getKey();
            NotificationChannelService service = entry.getValue();
            
            boolean isAvailable = service.isAvailable();
            
            Gauge.builder("notification.channel.available")
                .tag("channel", channelType.name().toLowerCase())
                .register(meterRegistry, isAvailable ? 1 : 0);
                
            if (!isAvailable) {
                logger.warn("Notification channel {} is not available", channelType);
            }
        }
    }
    
    // å‘Šè­¦è§„åˆ™
    @Bean
    public List<AlertRule> notificationAlertRules() {
        List<AlertRule> rules = new ArrayList<>();
        
        // é€šçŸ¥å¤±è´¥ç‡è¿‡é«˜å‘Šè­¦
        AlertRule failureRateRule = new AlertRule();
        failureRateRule.setName("High Notification Failure Rate");
        failureRateRule.setCondition("rate(notification_failure_count[5m]) / rate(notification_attempt_count[5m]) > 0.1");
        failureRateRule.setSeverity("warning");
        rules.add(failureRateRule);
        
        // é€šçŸ¥å»¶è¿Ÿè¿‡é«˜å‘Šè­¦
        AlertRule latencyRule = new AlertRule();
        latencyRule.setName("High Notification Latency");
        latencyRule.setCondition("notification_average_duration_seconds > 30");
        latencyRule.setSeverity("warning");
        rules.add(latencyRule);
        
        return rules;
    }
}
```

## ç»“è®º

å‘Šè­¦çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ååŠéƒ¨åˆ†â€”â€”é€šçŸ¥ä¸å“åº”ï¼Œæ˜¯ç¡®ä¿å‘Šè­¦ä»·å€¼å¾—ä»¥å®ç°çš„å…³é”®ç¯èŠ‚ã€‚é€šè¿‡å»ºç«‹å®Œå–„çš„åˆ†çº§é€šçŸ¥æœºåˆ¶ã€å¤šé€šé“é€šçŸ¥è·¯ç”±ã€æ™ºèƒ½å€¼ç­ç®¡ç†å’Œé«˜æ•ˆçš„åä½œæœºåˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥æ˜¾è‘—æå‡å‘Šè­¦å¤„ç†çš„æ•ˆç‡å’Œè´¨é‡ã€‚

å…³é”®è¦ç‚¹åŒ…æ‹¬ï¼š

1. **åˆ†çº§é€šçŸ¥**ï¼šæ ¹æ®å‘Šè­¦ä¸¥é‡æ€§å»ºç«‹å·®å¼‚åŒ–çš„é€šçŸ¥ç­–ç•¥
2. **å¤šé€šé“è·¯ç”±**ï¼šé›†æˆå¤šç§é€šçŸ¥æ¸ é“ç¡®ä¿ä¿¡æ¯è§¦è¾¾
3. **æ™ºèƒ½æ’ç­**ï¼šå»ºç«‹çµæ´»çš„å€¼ç­ç®¡ç†ä½“ç³»
4. **åä½œæœºåˆ¶**ï¼šæä¾›é«˜æ•ˆçš„å›¢é˜Ÿåä½œå·¥å…·
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡æ‰¹é‡å¤„ç†å’Œç¼“å­˜æå‡ç³»ç»Ÿæ€§èƒ½
6. **ç›‘æ§å‘Šè­¦**ï¼šå»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»ç¡®ä¿ç³»ç»Ÿç¨³å®š

é€šè¿‡åˆç†è®¾è®¡å’Œå®ç°è¿™äº›åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå‡ºçœŸæ­£é«˜æ•ˆã€å¯é çš„å‘Šè­¦å“åº”ä½“ç³»ï¼Œä¸ºä¸šåŠ¡çš„ç¨³å®šè¿è¡Œæä¾›æœ‰åŠ›ä¿éšœã€‚