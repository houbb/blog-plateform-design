---
title: å¤šé€šé“é€šçŸ¥è·¯ç”±: é›†æˆé’‰é’‰ã€ä¼å¾®ã€çŸ­ä¿¡ã€ç”µè¯ã€PagerDutyç­‰
date: 2025-08-30
categories: [Alarm]
tags: [alarm]
published: true
---
# å¤šé€šé“é€šçŸ¥è·¯ç”±ï¼šé›†æˆé’‰é’‰ã€ä¼å¾®ã€çŸ­ä¿¡ã€ç”µè¯ã€PagerDutyç­‰

åœ¨ç°ä»£è¿ç»´ç¯å¢ƒä¸­ï¼Œä¸åŒçš„å›¢é˜Ÿæˆå‘˜å’Œè§’è‰²å¯èƒ½åå¥½ä¸åŒçš„é€šçŸ¥æ–¹å¼ã€‚ä¸€ä¸ªé«˜æ•ˆçš„æŠ¥è­¦å¹³å°å¿…é¡»æ”¯æŒå¤šç§é€šçŸ¥æ¸ é“ï¼Œå¹¶èƒ½å¤Ÿæ ¹æ®å‘Šè­¦çš„ä¸¥é‡ç¨‹åº¦ã€æ¥æ”¶è€…è§’è‰²ä»¥åŠæ—¶é—´ç­‰å› ç´ ï¼Œæ™ºèƒ½åœ°é€‰æ‹©æœ€åˆé€‚çš„é€šçŸ¥æ–¹å¼ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å¦‚ä½•è®¾è®¡å’Œå®ç°ä¸€ä¸ªå¤šé€šé“é€šçŸ¥è·¯ç”±ç³»ç»Ÿã€‚

## ä¸ºä»€ä¹ˆéœ€è¦å¤šé€šé“é€šçŸ¥ï¼Ÿ

### 1. ä¸åŒåœºæ™¯ä¸‹çš„é€šçŸ¥éœ€æ±‚å·®å¼‚

åœ¨å®é™…è¿ç»´å·¥ä½œä¸­ï¼Œä¸åŒç±»å‹çš„å‘Šè­¦éœ€è¦ä¸åŒçš„å“åº”é€Ÿåº¦å’Œå¤„ç†æ–¹å¼ï¼š

- **ç´§æ€¥å‘Šè­¦**ï¼šå¦‚æ ¸å¿ƒæœåŠ¡å®•æœºï¼Œéœ€è¦ç«‹å³é€šçŸ¥ï¼Œé€šå¸¸é‡‡ç”¨ç”µè¯æˆ–å³æ—¶é€šè®¯å·¥å…·
- **é‡è¦å‘Šè­¦**ï¼šå¦‚æ€§èƒ½ä¸‹é™ï¼Œéœ€è¦å°½å¿«å¤„ç†ï¼Œé€šå¸¸é‡‡ç”¨å³æ—¶é€šè®¯å·¥å…·æˆ–çŸ­ä¿¡
- **ä¸€èˆ¬å‘Šè­¦**ï¼šå¦‚èµ„æºä½¿ç”¨ç‡é¢„è­¦ï¼Œå¯ä»¥ç¨åå¤„ç†ï¼Œé€šå¸¸é‡‡ç”¨é‚®ä»¶æˆ–å³æ—¶é€šè®¯å·¥å…·

### 2. æ¥æ”¶è€…åå¥½ä¸å¯ç”¨æ€§

ä¸åŒçš„æ¥æ”¶è€…å¯èƒ½æœ‰ä¸åŒçš„é€šçŸ¥åå¥½ï¼š

- **å¼€å‘äººå‘˜**ï¼šå¯èƒ½æ›´å–œæ¬¢ä½¿ç”¨å³æ—¶é€šè®¯å·¥å…·ï¼ˆå¦‚é’‰é’‰ã€ä¼ä¸šå¾®ä¿¡ï¼‰
- **è¿ç»´äººå‘˜**ï¼šå¯èƒ½éœ€è¦ç”µè¯é€šçŸ¥ä»¥ç¡®ä¿ç´§æ€¥æƒ…å†µä¸‹çš„å“åº”
- **ç®¡ç†å±‚**ï¼šå¯èƒ½æ›´å€¾å‘äºæ¥æ”¶é‚®ä»¶æ‘˜è¦

### 3. æ—¶é—´å› ç´ 

é€šçŸ¥çš„æœ‰æ•ˆæ€§å¾€å¾€ä¸æ—¶é—´å¯†åˆ‡ç›¸å…³ï¼š

- **å·¥ä½œæ—¶é—´**ï¼šå¯ä»¥ä½¿ç”¨å¤šç§é€šçŸ¥æ–¹å¼
- **éå·¥ä½œæ—¶é—´**ï¼šå¯èƒ½éœ€è¦æ›´ç›´æ¥çš„é€šçŸ¥æ–¹å¼ï¼ˆå¦‚ç”µè¯ï¼‰
- **èŠ‚å‡æ—¥**ï¼šå¯èƒ½éœ€è¦ç‰¹æ®Šçš„å¤„ç†ç­–ç•¥

## é€šçŸ¥æ¸ é“çš„æŠ€æœ¯å®ç°

### 1. é’‰é’‰é›†æˆ

é’‰é’‰ä½œä¸ºå›½å†…å¹¿æ³›ä½¿ç”¨çš„ä¼ä¸šé€šè®¯å·¥å…·ï¼Œæä¾›äº†ä¸°å¯Œçš„APIæ¥å£ä¾›ç¬¬ä¸‰æ–¹ç³»ç»Ÿé›†æˆã€‚

#### é’‰é’‰æœºå™¨äººå®ç°

```python
import requests
import json

class DingTalkNotifier:
    def __init__(self, webhook_url):
        self.webhook_url = webhook_url
    
    def send_text_message(self, content, at_mobiles=None, is_at_all=False):
        """
        å‘é€æ–‡æœ¬æ¶ˆæ¯åˆ°é’‰é’‰ç¾¤
        """
        payload = {
            "msgtype": "text",
            "text": {
                "content": content
            },
            "at": {
                "atMobiles": at_mobiles or [],
                "isAtAll": is_at_all
            }
        }
        
        response = requests.post(self.webhook_url, json=payload)
        return response.json()
    
    def send_markdown_message(self, title, text, at_mobiles=None, is_at_all=False):
        """
        å‘é€Markdownæ ¼å¼æ¶ˆæ¯åˆ°é’‰é’‰ç¾¤
        """
        payload = {
            "msgtype": "markdown",
            "markdown": {
                "title": title,
                "text": text
            },
            "at": {
                "atMobiles": at_mobiles or [],
                "isAtAll": is_at_all
            }
        }
        
        response = requests.post(self.webhook_url, json=payload)
        return response.json()

# ä½¿ç”¨ç¤ºä¾‹
notifier = DingTalkNotifier("https://oapi.dingtalk.com/robot/send?access_token=your_token")
notifier.send_markdown_message(
    title="ç´§æ€¥å‘Šè­¦",
    text="## ç´§æ€¥å‘Šè­¦\n\n- **æœåŠ¡åç§°**: User Service\n- **å‘Šè­¦å†…å®¹**: CPUä½¿ç”¨ç‡è¶…è¿‡90%\n- **æ—¶é—´**: 2025-08-30 10:30:00\n- **å¤„ç†å»ºè®®**: ç«‹å³æ£€æŸ¥æœåŠ¡è´Ÿè½½"
)
```

#### é’‰é’‰å·¥ä½œé€šçŸ¥å®ç°

å¯¹äºæ›´æ­£å¼çš„é€šçŸ¥ï¼Œå¯ä»¥ä½¿ç”¨é’‰é’‰çš„å·¥ä½œé€šçŸ¥APIï¼š

```python
import requests

class DingTalkWorkNotifier:
    def __init__(self, app_key, app_secret):
        self.app_key = app_key
        self.app_secret = app_secret
        self.access_token = self._get_access_token()
    
    def _get_access_token(self):
        """
        è·å–è®¿é—®ä»¤ç‰Œ
        """
        url = "https://oapi.dingtalk.com/gettoken"
        params = {
            "appkey": self.app_key,
            "appsecret": self.app_secret
        }
        response = requests.get(url, params=params)
        return response.json().get("access_token")
    
    def send_work_message(self, user_id, msg_content):
        """
        å‘é€å·¥ä½œé€šçŸ¥
        """
        url = "https://oapi.dingtalk.com/topapi/message/corpconversation/asyncsend_v2"
        headers = {"Content-Type": "application/json"}
        payload = {
            "agent_id": "your_agent_id",
            "userid_list": user_id,
            "msg": {
                "msgtype": "text",
                "text": {
                    "content": msg_content
                }
            }
        }
        
        response = requests.post(url, headers=headers, json=payload, params={"access_token": self.access_token})
        return response.json()
```

### 2. ä¼ä¸šå¾®ä¿¡é›†æˆ

ä¼ä¸šå¾®ä¿¡åŒæ ·æä¾›äº†ä¸°å¯Œçš„APIæ¥å£ï¼Œæ”¯æŒå¤šç§æ¶ˆæ¯ç±»å‹ï¼š

```python
import requests

class WeComNotifier:
    def __init__(self, corpid, corpsecret, agentid):
        self.corpid = corpid
        self.corpsecret = corpsecret
        self.agentid = agentid
        self.access_token = self._get_access_token()
    
    def _get_access_token(self):
        """
        è·å–è®¿é—®ä»¤ç‰Œ
        """
        url = "https://qyapi.weixin.qq.com/cgi-bin/gettoken"
        params = {
            "corpid": self.corpid,
            "corpsecret": self.corpsecret
        }
        response = requests.get(url, params=params)
        return response.json().get("access_token")
    
    def send_text_message(self, touser, content):
        """
        å‘é€æ–‡æœ¬æ¶ˆæ¯
        """
        url = "https://qyapi.weixin.qq.com/cgi-bin/message/send"
        payload = {
            "touser": touser,
            "msgtype": "text",
            "agentid": self.agentid,
            "text": {
                "content": content
            },
            "safe": 0
        }
        
        response = requests.post(url, json=payload, params={"access_token": self.access_token})
        return response.json()
```

### 3. çŸ­ä¿¡é€šçŸ¥å®ç°

çŸ­ä¿¡é€šçŸ¥é€šå¸¸é€šè¿‡ç¬¬ä¸‰æ–¹çŸ­ä¿¡æœåŠ¡æä¾›å•†å®ç°ï¼š

```python
import requests

class SMSNotifier:
    def __init__(self, api_key, api_secret, from_number):
        self.api_key = api_key
        self.api_secret = api_secret
        self.from_number = from_number
    
    def send_sms(self, to_number, message):
        """
        å‘é€çŸ­ä¿¡
        """
        url = "https://api.smsprovider.com/messages"
        headers = {
            "Authorization": f"Basic {self._encode_credentials()}",
            "Content-Type": "application/json"
        }
        payload = {
            "from": self.from_number,
            "to": to_number,
            "text": message
        }
        
        response = requests.post(url, headers=headers, json=payload)
        return response.json()
    
    def _encode_credentials(self):
        """
        ç¼–ç è®¤è¯ä¿¡æ¯
        """
        import base64
        credentials = f"{self.api_key}:{self.api_secret}"
        return base64.b64encode(credentials.encode()).decode()
```

### 4. ç”µè¯é€šçŸ¥å®ç°

ç”µè¯é€šçŸ¥é€šå¸¸é€šè¿‡è¯­éŸ³æœåŠ¡æä¾›å•†å®ç°ï¼š

```python
import requests

class VoiceNotifier:
    def __init__(self, api_key, api_secret):
        self.api_key = api_key
        self.api_secret = api_secret
    
    def make_call(self, to_number, message):
        """
        å‘èµ·è¯­éŸ³å‘¼å«
        """
        url = "https://api.voiceprovider.com/calls"
        headers = {
            "Authorization": f"Basic {self._encode_credentials()}",
            "Content-Type": "application/json"
        }
        payload = {
            "to": to_number,
            "text": message,
            "voice": "alice"
        }
        
        response = requests.post(url, headers=headers, json=payload)
        return response.json()
    
    def _encode_credentials(self):
        """
        ç¼–ç è®¤è¯ä¿¡æ¯
        """
        import base64
        credentials = f"{self.api_key}:{self.api_secret}"
        return base64.b64encode(credentials.encode()).decode()
```

## é€šçŸ¥è·¯ç”±ç­–ç•¥è®¾è®¡

### 1. åŸºäºè§’è‰²çš„é€šçŸ¥ç­–ç•¥

```yaml
notification_routes:
  - name: "å¼€å‘å›¢é˜Ÿç´§æ€¥å‘Šè­¦"
    conditions:
      severity: "critical"
      team: "development"
    channels:
      - type: "dingtalk"
        priority: 1
        timeout: 300  # 5åˆ†é’Ÿè¶…æ—¶
      - type: "sms"
        priority: 2
        timeout: 600  # 10åˆ†é’Ÿè¶…æ—¶
      - type: "voice"
        priority: 3
        timeout: 1200 # 20åˆ†é’Ÿè¶…æ—¶
  
  - name: "è¿ç»´å›¢é˜Ÿå‘Šè­¦"
    conditions:
      severity: "warning"
      team: "operations"
    channels:
      - type: "wechat_work"
        priority: 1
        timeout: 600
      - type: "sms"
        priority: 2
        timeout: 1200
```

### 2. åŸºäºæ—¶é—´çš„é€šçŸ¥ç­–ç•¥

```python
from datetime import datetime

class TimeBasedRouter:
    def __init__(self):
        self.work_hours_start = 9  # ä¸Šç­æ—¶é—´
        self.work_hours_end = 18   # ä¸‹ç­æ—¶é—´
    
    def is_work_hours(self):
        """
        åˆ¤æ–­å½“å‰æ˜¯å¦ä¸ºå·¥ä½œæ—¶é—´
        """
        now = datetime.now()
        current_hour = now.hour
        # å·¥ä½œæ—¥åˆ¤æ–­ï¼ˆå‘¨ä¸€åˆ°å‘¨äº”ï¼‰
        is_weekday = now.weekday() < 5
        is_work_hour = self.work_hours_start <= current_hour < self.work_hours_end
        return is_weekday and is_work_hour
    
    def select_channels(self, severity):
        """
        æ ¹æ®æ—¶é—´å’Œå‘Šè­¦ä¸¥é‡ç¨‹åº¦é€‰æ‹©é€šçŸ¥æ¸ é“
        """
        if self.is_work_hours():
            if severity == "critical":
                return ["dingtalk", "sms"]
            elif severity == "warning":
                return ["dingtalk"]
            else:
                return ["email"]
        else:
            if severity == "critical":
                return ["voice", "sms", "dingtalk"]
            elif severity == "warning":
                return ["sms", "dingtalk"]
            else:
                return ["sms"]
```

### 3. åŸºäºæ¥æ”¶è€…åå¥½çš„é€šçŸ¥ç­–ç•¥

```python
class PreferenceBasedRouter:
    def __init__(self, user_preferences):
        self.user_preferences = user_preferences
    
    def get_user_channels(self, user_id, severity):
        """
        æ ¹æ®ç”¨æˆ·åå¥½å’Œå‘Šè­¦ä¸¥é‡ç¨‹åº¦é€‰æ‹©é€šçŸ¥æ¸ é“
        """
        user_pref = self.user_preferences.get(user_id, {})
        severity_prefs = user_pref.get("severity_preferences", {})
        
        # è·å–ç‰¹å®šä¸¥é‡ç¨‹åº¦çš„åå¥½è®¾ç½®
        channels = severity_prefs.get(severity, [])
        
        # å¦‚æœæ²¡æœ‰ç‰¹å®šè®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤è®¾ç½®
        if not channels:
            channels = user_pref.get("default_channels", ["email"])
        
        return channels
```

## é€šçŸ¥è·¯ç”±å¼•æ“å®ç°

### 1. è·¯ç”±å¼•æ“æ ¸å¿ƒé€»è¾‘

```python
class NotificationRouter:
    def __init__(self, channel_configs, routing_rules):
        self.channels = self._init_channels(channel_configs)
        self.routing_rules = routing_rules
    
    def _init_channels(self, channel_configs):
        """
        åˆå§‹åŒ–é€šçŸ¥æ¸ é“
        """
        channels = {}
        for config in channel_configs:
            channel_type = config["type"]
            if channel_type == "dingtalk":
                channels[channel_type] = DingTalkNotifier(config["webhook_url"])
            elif channel_type == "wechat_work":
                channels[channel_type] = WeComNotifier(
                    config["corpid"], 
                    config["corpsecret"], 
                    config["agentid"]
                )
            elif channel_type == "sms":
                channels[channel_type] = SMSNotifier(
                    config["api_key"], 
                    config["api_secret"], 
                    config["from_number"]
                )
            elif channel_type == "voice":
                channels[channel_type] = VoiceNotifier(
                    config["api_key"], 
                    config["api_secret"]
                )
        return channels
    
    def route_notification(self, alert, recipients):
        """
        è·¯ç”±é€šçŸ¥åˆ°åˆé€‚çš„æ¸ é“
        """
        for recipient in recipients:
            # è·å–è·¯ç”±è§„åˆ™
            rules = self._get_applicable_rules(alert, recipient)
            
            # æŒ‰ä¼˜å…ˆçº§æ’åºè§„åˆ™
            rules.sort(key=lambda x: x.get("priority", 0))
            
            # åº”ç”¨è§„åˆ™
            for rule in rules:
                channels = rule.get("channels", [])
                for channel_info in channels:
                    channel_type = channel_info["type"]
                    channel = self.channels.get(channel_type)
                    if channel:
                        # å‘é€é€šçŸ¥
                        self._send_notification(channel, alert, recipient, channel_info)
    
    def _get_applicable_rules(self, alert, recipient):
        """
        è·å–é€‚ç”¨äºç‰¹å®šå‘Šè­¦å’Œæ¥æ”¶è€…çš„è·¯ç”±è§„åˆ™
        """
        applicable_rules = []
        for rule in self.routing_rules:
            if self._matches_condition(rule.get("conditions", {}), alert, recipient):
                applicable_rules.append(rule)
        return applicable_rules
    
    def _matches_condition(self, conditions, alert, recipient):
        """
        æ£€æŸ¥æ¡ä»¶æ˜¯å¦åŒ¹é…
        """
        # æ£€æŸ¥å‘Šè­¦ä¸¥é‡ç¨‹åº¦
        if "severity" in conditions:
            if alert.get("severity") != conditions["severity"]:
                return False
        
        # æ£€æŸ¥æ¥æ”¶è€…å›¢é˜Ÿ
        if "team" in conditions:
            if recipient.get("team") != conditions["team"]:
                return False
        
        return True
    
    def _send_notification(self, channel, alert, recipient, channel_info):
        """
        å‘é€é€šçŸ¥
        """
        # æ„é€ é€šçŸ¥å†…å®¹
        content = self._format_alert_content(alert, recipient)
        
        # å‘é€é€šçŸ¥
        try:
            if isinstance(channel, DingTalkNotifier):
                channel.send_markdown_message(
                    title=f"å‘Šè­¦é€šçŸ¥ - {alert['severity'].upper()}",
                    text=content
                )
            elif isinstance(channel, WeComNotifier):
                channel.send_text_message(recipient["user_id"], content)
            elif isinstance(channel, SMSNotifier):
                channel.send_sms(recipient["phone"], content)
            elif isinstance(channel, VoiceNotifier):
                channel.make_call(recipient["phone"], content)
        except Exception as e:
            print(f"å‘é€é€šçŸ¥å¤±è´¥: {e}")
    
    def _format_alert_content(self, alert, recipient):
        """
        æ ¼å¼åŒ–å‘Šè­¦å†…å®¹
        """
        return f"""
å‘Šè­¦é€šçŸ¥

æœåŠ¡åç§°: {alert.get('service_name', 'Unknown')}
å‘Šè­¦å†…å®¹: {alert.get('message', 'No message')}
ä¸¥é‡ç¨‹åº¦: {alert.get('severity', 'Unknown')}
æ—¶é—´: {alert.get('timestamp', 'Unknown')}
å¤„ç†å»ºè®®: {alert.get('suggestion', 'Please check the service')}
        """.strip()
```

### 2. é…ç½®æ–‡ä»¶ç¤ºä¾‹

```yaml
# channel_configs.yaml
channels:
  - type: "dingtalk"
    name: "å¼€å‘å›¢é˜Ÿé’‰é’‰ç¾¤"
    webhook_url: "https://oapi.dingtalk.com/robot/send?access_token=dev_token"
  
  - type: "wechat_work"
    name: "è¿ç»´å›¢é˜Ÿä¼ä¸šå¾®ä¿¡"
    corpid: "your_corpid"
    corpsecret: "your_corpsecret"
    agentid: "your_agentid"
  
  - type: "sms"
    name: "çŸ­ä¿¡æœåŠ¡"
    api_key: "your_sms_api_key"
    api_secret: "your_sms_api_secret"
    from_number: "+1234567890"
  
  - type: "voice"
    name: "è¯­éŸ³æœåŠ¡"
    api_key: "your_voice_api_key"
    api_secret: "your_voice_api_secret"

# routing_rules.yaml
routing_rules:
  - name: "å¼€å‘å›¢é˜Ÿç´§æ€¥å‘Šè­¦"
    conditions:
      severity: "critical"
      team: "development"
    priority: 1
    channels:
      - type: "dingtalk"
        timeout: 300
      - type: "sms"
        timeout: 600
      - type: "voice"
        timeout: 1200
  
  - name: "è¿ç»´å›¢é˜Ÿé‡è¦å‘Šè­¦"
    conditions:
      severity: "warning"
      team: "operations"
    priority: 2
    channels:
      - type: "wechat_work"
        timeout: 600
      - type: "sms"
        timeout: 1200
```

## é€šçŸ¥é€è¾¾ä¿éšœæœºåˆ¶

### 1. é€šçŸ¥ç¡®è®¤æœºåˆ¶

```python
class NotificationConfirmation:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def record_notification(self, alert_id, recipient_id, channel, status):
        """
        è®°å½•é€šçŸ¥å‘é€çŠ¶æ€
        """
        query = """
        INSERT INTO notification_records 
        (alert_id, recipient_id, channel, status, sent_at)
        VALUES (%s, %s, %s, %s, NOW())
        """
        self.db.execute(query, (alert_id, recipient_id, channel, status))
    
    def check_confirmation(self, alert_id, recipient_id, timeout=3600):
        """
        æ£€æŸ¥æ˜¯å¦æ”¶åˆ°ç¡®è®¤
        """
        query = """
        SELECT COUNT(*) FROM notification_confirmations
        WHERE alert_id = %s AND recipient_id = %s 
        AND confirmed_at > NOW() - INTERVAL %s SECOND
        """
        result = self.db.execute(query, (alert_id, recipient_id, timeout))
        return result[0][0] > 0
```

### 2. é‡è¯•æœºåˆ¶

```python
import time
from datetime import datetime, timedelta

class NotificationRetry:
    def __init__(self, max_retries=3, retry_interval=300):
        self.max_retries = max_retries
        self.retry_interval = retry_interval  # ç§’
    
    def should_retry(self, notification_record):
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•
        """
        # æ£€æŸ¥é‡è¯•æ¬¡æ•°
        if notification_record.retry_count >= self.max_retries:
            return False
        
        # æ£€æŸ¥æ—¶é—´é—´éš”
        last_sent = notification_record.last_sent_at
        if datetime.now() - last_sent < timedelta(seconds=self.retry_interval):
            return False
        
        # æ£€æŸ¥æ˜¯å¦å·²ç¡®è®¤
        if notification_record.status == "confirmed":
            return False
        
        return True
    
    def schedule_retry(self, notification_record):
        """
        å®‰æ’é‡è¯•
        """
        notification_record.retry_count += 1
        notification_record.last_sent_at = datetime.now()
        notification_record.status = "pending"
        # æ›´æ–°æ•°æ®åº“è®°å½•
        self.update_notification_record(notification_record)
```

## é€šçŸ¥æ•ˆæœåº¦é‡

### 1. å…³é”®æŒ‡æ ‡å®šä¹‰

```python
class NotificationMetrics:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def calculate_delivery_rate(self, start_time, end_time):
        """
        è®¡ç®—é€šçŸ¥é€è¾¾ç‡
        """
        query = """
        SELECT 
            COUNT(*) as total,
            SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered
        FROM notification_records
        WHERE sent_at BETWEEN %s AND %s
        """
        result = self.db.execute(query, (start_time, end_time))
        total, delivered = result[0]
        return delivered / total if total > 0 else 0
    
    def calculate_response_time(self, start_time, end_time):
        """
        è®¡ç®—å¹³å‡å“åº”æ—¶é—´
        """
        query = """
        SELECT AVG(TIMESTAMPDIFF(SECOND, nr.sent_at, nc.confirmed_at)) as avg_response_time
        FROM notification_records nr
        JOIN notification_confirmations nc ON nr.id = nc.notification_id
        WHERE nr.sent_at BETWEEN %s AND %s
        """
        result = self.db.execute(query, (start_time, end_time))
        return result[0][0] or 0
    
    def calculate_channel_effectiveness(self, start_time, end_time):
        """
        è®¡ç®—å„æ¸ é“æ•ˆæœ
        """
        query = """
        SELECT 
            channel,
            COUNT(*) as total,
            SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
            AVG(TIMESTAMPDIFF(SECOND, sent_at, 
                (SELECT confirmed_at FROM notification_confirmations nc 
                 WHERE nc.notification_id = notification_records.id LIMIT 1))) as avg_response_time
        FROM notification_records
        WHERE sent_at BETWEEN %s AND %s
        GROUP BY channel
        """
        result = self.db.execute(query, (start_time, end_time))
        return result
```

### 2. æ•ˆæœå¯è§†åŒ–

```python
import matplotlib.pyplot as plt

class NotificationDashboard:
    def __init__(self, metrics):
        self.metrics = metrics
    
    def plot_delivery_trends(self, days=30):
        """
        ç»˜åˆ¶é€šçŸ¥é€è¾¾è¶‹åŠ¿å›¾
        """
        # è·å–æ•°æ®
        data = self.metrics.get_delivery_trends(days)
        
        # ç»˜å›¾
        plt.figure(figsize=(12, 6))
        plt.plot(data['dates'], data['delivery_rates'], marker='o')
        plt.title('é€šçŸ¥é€è¾¾ç‡è¶‹åŠ¿')
        plt.xlabel('æ—¥æœŸ')
        plt.ylabel('é€è¾¾ç‡ (%)')
        plt.grid(True)
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig('delivery_trends.png')
        plt.show()
    
    def plot_channel_comparison(self):
        """
        ç»˜åˆ¶å„æ¸ é“æ•ˆæœå¯¹æ¯”å›¾
        """
        # è·å–æ•°æ®
        data = self.metrics.get_channel_effectiveness()
        
        # ç»˜å›¾
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        # é€è¾¾ç‡å¯¹æ¯”
        channels = [d['channel'] for d in data]
        delivery_rates = [d['delivered']/d['total']*100 for d in data]
        ax1.bar(channels, delivery_rates)
        ax1.set_title('å„æ¸ é“é€è¾¾ç‡å¯¹æ¯”')
        ax1.set_ylabel('é€è¾¾ç‡ (%)')
        ax1.tick_params(axis='x', rotation=45)
        
        # å“åº”æ—¶é—´å¯¹æ¯”
        response_times = [d['avg_response_time'] for d in data]
        ax2.bar(channels, response_times)
        ax2.set_title('å„æ¸ é“å¹³å‡å“åº”æ—¶é—´å¯¹æ¯”')
        ax2.set_ylabel('å“åº”æ—¶é—´ (ç§’)')
        ax2.tick_params(axis='x', rotation=45)
        
        plt.tight_layout()
        plt.savefig('channel_comparison.png')
        plt.show()
```

## æœ€ä½³å®è·µä¸æ³¨æ„äº‹é¡¹

### 1. é¿å…é€šçŸ¥éªšæ‰°

```python
class NotificationThrottler:
    def __init__(self, db_connection, max_notifications_per_hour=10):
        self.db = db_connection
        self.max_notifications_per_hour = max_notifications_per_hour
    
    def is_throttled(self, recipient_id):
        """
        æ£€æŸ¥æ¥æ”¶è€…æ˜¯å¦è¢«é™æµ
        """
        query = """
        SELECT COUNT(*) FROM notification_records
        WHERE recipient_id = %s 
        AND sent_at > NOW() - INTERVAL 1 HOUR
        """
        result = self.db.execute(query, (recipient_id,))
        return result[0][0] >= self.max_notifications_per_hour
    
    def apply_throttling(self, alert, recipients):
        """
        åº”ç”¨é™æµç­–ç•¥
        """
        filtered_recipients = []
        for recipient in recipients:
            if not self.is_throttled(recipient["id"]):
                filtered_recipients.append(recipient)
            else:
                print(f"Recipient {recipient['id']} is throttled, skipping notification")
        return filtered_recipients
```

### 2. é€šçŸ¥å†…å®¹ä¼˜åŒ–

```python
class NotificationContentOptimizer:
    def optimize_content(self, alert):
        """
        ä¼˜åŒ–é€šçŸ¥å†…å®¹
        """
        # ç²¾ç®€å†…å®¹
        optimized_message = self._truncate_message(alert["message"])
        
        # æ·»åŠ å…³é”®ä¿¡æ¯
        key_info = self._extract_key_info(alert)
        
        # æ ¼å¼åŒ–è¾“å‡º
        formatted_content = f"""
ğŸš¨ {alert['severity'].upper()} å‘Šè­¦ ğŸš¨

{optimized_message}

å…³é”®ä¿¡æ¯:
{key_info}

å¤„ç†å»ºè®®:
{alert.get('suggestion', 'è¯·å°½å¿«å¤„ç†')}
        """.strip()
        
        return formatted_content
    
    def _truncate_message(self, message, max_length=200):
        """
        æˆªæ–­è¿‡é•¿çš„æ¶ˆæ¯
        """
        if len(message) <= max_length:
            return message
        return message[:max_length-3] + "..."
    
    def _extract_key_info(self, alert):
        """
        æå–å…³é”®ä¿¡æ¯
        """
        key_info = []
        if alert.get("service_name"):
            key_info.append(f"æœåŠ¡: {alert['service_name']}")
        if alert.get("host"):
            key_info.append(f"ä¸»æœº: {alert['host']}")
        if alert.get("timestamp"):
            key_info.append(f"æ—¶é—´: {alert['timestamp']}")
        return "\n".join(key_info)
```

## æ€»ç»“

å¤šé€šé“é€šçŸ¥è·¯ç”±æ˜¯ç°ä»£æŠ¥è­¦å¹³å°çš„æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€ã€‚é€šè¿‡åˆç†è®¾è®¡é€šçŸ¥ç­–ç•¥ã€å®ç°å¤šç§é€šçŸ¥æ¸ é“çš„é›†æˆã€å»ºç«‹å®Œå–„çš„é€è¾¾ä¿éšœæœºåˆ¶ä»¥åŠæŒç»­ä¼˜åŒ–é€šçŸ¥æ•ˆæœï¼Œå¯ä»¥æ˜¾è‘—æå‡å‘Šè­¦çš„å“åº”æ•ˆç‡å’Œç”¨æˆ·ä½“éªŒã€‚

å…³é”®è¦ç‚¹åŒ…æ‹¬ï¼š

1. **å¤šæ ·åŒ–æ¸ é“æ”¯æŒ**ï¼šé›†æˆé’‰é’‰ã€ä¼ä¸šå¾®ä¿¡ã€çŸ­ä¿¡ã€ç”µè¯ç­‰å¤šç§é€šçŸ¥æ–¹å¼
2. **æ™ºèƒ½è·¯ç”±ç­–ç•¥**ï¼šåŸºäºè§’è‰²ã€æ—¶é—´ã€æ¥æ”¶è€…åå¥½ç­‰å› ç´ åˆ¶å®šçµæ´»çš„é€šçŸ¥ç­–ç•¥
3. **é€è¾¾ä¿éšœæœºåˆ¶**ï¼šé€šè¿‡ç¡®è®¤æœºåˆ¶ã€é‡è¯•æœºåˆ¶ç¡®ä¿é€šçŸ¥æœ‰æ•ˆé€è¾¾
4. **æ•ˆæœåº¦é‡ä¼˜åŒ–**ï¼šæŒç»­ç›‘æ§å’Œä¼˜åŒ–é€šçŸ¥æ•ˆæœï¼Œæå‡æ•´ä½“è´¨é‡
5. **ç”¨æˆ·ä½“éªŒå…³æ€€**ï¼šé¿å…é€šçŸ¥éªšæ‰°ï¼Œä¼˜åŒ–é€šçŸ¥å†…å®¹ï¼Œæå‡ç”¨æˆ·æ»¡æ„åº¦

é€šè¿‡ä»¥ä¸Šè®¾è®¡å’Œå®ç°ï¼Œå¯ä»¥æ„å»ºä¸€ä¸ªé«˜æ•ˆã€å¯é ã€ç”¨æˆ·å‹å¥½çš„å¤šé€šé“é€šçŸ¥è·¯ç”±ç³»ç»Ÿï¼Œä¸ºæŠ¥è­¦å¹³å°çš„æˆåŠŸè½åœ°æä¾›æœ‰åŠ›æ”¯æ’‘ã€‚