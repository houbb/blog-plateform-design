---
title: "ä¸ç”Ÿæ€ç³»ç»Ÿçš„é›†æˆ: é¡¹ç›®ç®¡ç†ã€ç›‘æ§ã€æ²Ÿé€šå·¥å…·çš„æ•´åˆ"
date: 2025-08-30
categories: [CICD]
tags: [ci,cd,ecosystem,integration,devops,project-management,monitoring,communication]
published: true
---
åœ¨ç°ä»£è½¯ä»¶å¼€å‘å®è·µä¸­ï¼ŒCI/CDå¹³å°ä¸å†æ˜¯å­¤ç«‹å­˜åœ¨çš„å·¥å…·ï¼Œè€Œæ˜¯éœ€è¦ä¸æ•´ä¸ªç ”å‘ç”Ÿæ€ç³»ç»Ÿæ·±åº¦é›†æˆçš„æ ¸å¿ƒç»„ä»¶ã€‚é€šè¿‡ä¸é¡¹ç›®ç®¡ç†å·¥å…·ã€ç›‘æ§ç³»ç»Ÿã€æ²Ÿé€šå·¥å…·ç­‰ç¬¬ä¸‰æ–¹ç³»ç»Ÿçš„æ— ç¼é›†æˆï¼ŒCI/CDå¹³å°èƒ½å¤Ÿå®ç°ç«¯åˆ°ç«¯çš„è‡ªåŠ¨åŒ–æµç¨‹ï¼Œæå‡å›¢é˜Ÿåä½œæ•ˆç‡ï¼Œå¢å¼ºç³»ç»Ÿå¯è§‚æµ‹æ€§ï¼Œå¹¶ç¡®ä¿è½¯ä»¶äº¤ä»˜çš„é«˜è´¨é‡ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å¦‚ä½•å®ç°CI/CDå¹³å°ä¸å„ç±»ç”Ÿæ€ç³»ç»Ÿçš„æœ‰æ•ˆé›†æˆã€‚

## é›†æˆæ¶æ„è®¾è®¡

CI/CDå¹³å°ä¸ç”Ÿæ€ç³»ç»Ÿé›†æˆéœ€è¦è€ƒè™‘æ¶æ„è®¾è®¡çš„åˆç†æ€§ã€æ‰©å±•æ€§å’Œå®‰å…¨æ€§ã€‚

### 1. é›†æˆæ¨¡å¼é€‰æ‹©

æ ¹æ®ä¸åŒçš„é›†æˆéœ€æ±‚å’Œç³»ç»Ÿç‰¹æ€§ï¼Œå¯ä»¥é€‰æ‹©ä¸åŒçš„é›†æˆæ¨¡å¼ï¼š

#### Webhookæ¨¡å¼
åŸºäºäº‹ä»¶é©±åŠ¨çš„å¼‚æ­¥é›†æˆæ–¹å¼ï¼Œé€‚ç”¨äºå®æ—¶æ€§è¦æ±‚ä¸é«˜çš„åœºæ™¯ï¼š
- **ä¼˜åŠ¿**ï¼šå®ç°ç®€å•ï¼Œæ¾è€¦åˆï¼Œæ”¯æŒå¤šç§åè®®
- **åŠ£åŠ¿**ï¼šéœ€è¦å¤„ç†é‡è¯•ã€å¹‚ç­‰æ€§ç­‰é—®é¢˜
- **é€‚ç”¨åœºæ™¯**ï¼šé€šçŸ¥ç±»é›†æˆã€çŠ¶æ€åŒæ­¥

#### APIè°ƒç”¨æ¨¡å¼
é€šè¿‡ä¸»åŠ¨è°ƒç”¨ç¬¬ä¸‰æ–¹ç³»ç»ŸAPIå®ç°é›†æˆï¼š
- **ä¼˜åŠ¿**ï¼šæ§åˆ¶åŠ›å¼ºï¼Œå¯è·å–å®æ—¶æ•°æ®
- **åŠ£åŠ¿**ï¼šéœ€è¦å¤„ç†è®¤è¯ã€é™æµç­‰é—®é¢˜
- **é€‚ç”¨åœºæ™¯**ï¼šæ•°æ®è·å–ã€é…ç½®ç®¡ç†

#### æ¶ˆæ¯é˜Ÿåˆ—æ¨¡å¼
é€šè¿‡æ¶ˆæ¯é˜Ÿåˆ—å®ç°å¼‚æ­¥è§£è€¦çš„é›†æˆï¼š
- **ä¼˜åŠ¿**ï¼šé«˜å¯ç”¨ï¼Œæ”¯æŒæµé‡å‰Šå³°
- **åŠ£åŠ¿**ï¼šæ¶æ„å¤æ‚åº¦é«˜
- **é€‚ç”¨åœºæ™¯**ï¼šå¤§æ•°æ®é‡ä¼ è¾“ã€å¤æ‚ä¸šåŠ¡æµç¨‹

### 2. é›†æˆå®‰å…¨è®¾è®¡

ç¡®ä¿é›†æˆè¿‡ç¨‹ä¸­çš„æ•°æ®å®‰å…¨å’Œè®¿é—®æ§åˆ¶ï¼š

#### è®¤è¯æœºåˆ¶
```yaml
# é›†æˆè®¤è¯é…ç½®ç¤ºä¾‹
integrations:
  jira:
    type: "oauth2"
    client_id: "ci-cd-platform"
    client_secret: "${JIRA_CLIENT_SECRET}"
    token_url: "https://your-domain.atlassian.net/oauth/token"
    scopes:
      - "read:jira-work"
      - "write:jira-work"
  
  slack:
    type: "webhook"
    webhook_url: "${SLACK_WEBHOOK_URL}"
    verification_token: "${SLACK_VERIFICATION_TOKEN}"
  
  prometheus:
    type: "basic_auth"
    username: "ci-cd-monitor"
    password: "${PROMETHEUS_PASSWORD}"
```

#### æ•°æ®åŠ å¯†
```python
#!/usr/bin/env python3
"""
é›†æˆå®‰å…¨å·¥å…·
å¤„ç†è®¤è¯å’Œæ•°æ®åŠ å¯†
"""

import hashlib
import hmac
import base64
import json
import logging
from typing import Dict, Any
from cryptography.fernet import Fernet

class IntegrationSecurity:
    def __init__(self, encryption_key: str = None):
        self.logger = logging.getLogger(__name__)
        self.encryption_key = encryption_key or Fernet.generate_key()
        self.cipher = Fernet(self.encryption_key)
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """åŠ å¯†æ•æ„Ÿæ•°æ®"""
        try:
            encrypted_data = self.cipher.encrypt(data.encode())
            return base64.urlsafe_b64encode(encrypted_data).decode()
        except Exception as e:
            self.logger.error(f"Failed to encrypt data: {e}")
            raise
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """è§£å¯†æ•æ„Ÿæ•°æ®"""
        try:
            decoded_data = base64.urlsafe_b64decode(encrypted_data.encode())
            decrypted_data = self.cipher.decrypt(decoded_data)
            return decrypted_data.decode()
        except Exception as e:
            self.logger.error(f"Failed to decrypt data: {e}")
            raise
    
    def generate_signature(self, payload: Dict[str, Any], secret: str) -> str:
        """ç”Ÿæˆç­¾åéªŒè¯è¯·æ±‚å®Œæ•´æ€§"""
        payload_str = json.dumps(payload, sort_keys=True)
        signature = hmac.new(
            secret.encode(),
            payload_str.encode(),
            hashlib.sha256
        ).hexdigest()
        return signature
    
    def verify_signature(self, payload: Dict[str, Any], secret: str, signature: str) -> bool:
        """éªŒè¯ç­¾å"""
        expected_signature = self.generate_signature(payload, secret)
        return hmac.compare_digest(expected_signature, signature)
```

### 3. é›†æˆé…ç½®ç®¡ç†

ç»Ÿä¸€ç®¡ç†å„ç±»é›†æˆé…ç½®ï¼š

#### é…ç½®ä¸­å¿ƒè®¾è®¡
```yaml
# é›†æˆé…ç½®ä¸­å¿ƒç¤ºä¾‹
integration_configs:
  project_management:
    jira:
      enabled: true
      base_url: "https://your-domain.atlassian.net"
      auth:
        type: "oauth2"
        client_id: "ci-cd-platform"
        client_secret_ref: "jira-client-secret"
      project_mapping:
        "PROJ1": "project-key-1"
        "PROJ2": "project-key-2"
    
    azure_devops:
      enabled: false
      base_url: "https://dev.azure.com"
      auth:
        type: "pat"
        token_ref: "azure-devops-pat"
  
  monitoring:
    prometheus:
      enabled: true
      url: "http://prometheus:9090"
      auth:
        type: "basic"
        username: "monitor"
        password_ref: "prometheus-password"
    
    datadog:
      enabled: true
      api_key_ref: "datadog-api-key"
      app_key_ref: "datadog-app-key"
  
  communication:
    slack:
      enabled: true
      webhook_url_ref: "slack-webhook-url"
      channels:
        "build-notifications": "#ci-cd-notifications"
        "deployment-status": "#deployments"
    
    dingtalk:
      enabled: true
      webhook_url_ref: "dingtalk-webhook-url"
      secret_ref: "dingtalk-secret"
```

## ä¸é¡¹ç›®ç®¡ç†å·¥å…·é›†æˆ

é¡¹ç›®ç®¡ç†å·¥å…·é›†æˆèƒ½å¤Ÿå®ç°éœ€æ±‚é©±åŠ¨çš„éƒ¨ç½²å’Œç«¯åˆ°ç«¯çš„å¯è¿½æº¯æ€§ã€‚

### 1. Jiraé›†æˆå®è·µ

Jiraä½œä¸ºå¹¿æ³›ä½¿ç”¨çš„é¡¹ç›®ç®¡ç†å·¥å…·ï¼Œä¸å…¶é›†æˆèƒ½å¤Ÿå®ç°éœ€æ±‚ä¸ä»£ç çš„å…³è”ã€‚

#### é›†æˆåŠŸèƒ½è®¾è®¡
```python
#!/usr/bin/env python3
"""
Jiraé›†æˆå·¥å…·
å®ç°ä¸Jiraç³»ç»Ÿçš„æ·±åº¦é›†æˆ
"""

import requests
import json
import logging
from typing import Dict, List, Optional
from datetime import datetime

class JiraIntegration:
    def __init__(self, base_url: str, auth_config: Dict):
        self.base_url = base_url.rstrip('/')
        self.auth_config = auth_config
        self.logger = logging.getLogger(__name__)
        self.session = requests.Session()
        self._setup_authentication()
    
    def _setup_authentication(self):
        """è®¾ç½®è®¤è¯ä¿¡æ¯"""
        if self.auth_config['type'] == 'oauth2':
            # OAuth2è®¤è¯è®¾ç½®
            self.session.headers.update({
                'Authorization': f"Bearer {self._get_oauth2_token()}"
            })
        elif self.auth_config['type'] == 'basic':
            # Basicè®¤è¯è®¾ç½®
            from requests.auth import HTTPBasicAuth
            self.session.auth = HTTPBasicAuth(
                self.auth_config['username'],
                self.auth_config['password']
            )
        elif self.auth_config['type'] == 'token':
            # Tokenè®¤è¯è®¾ç½®
            self.session.headers.update({
                'Authorization': f"Bearer {self.auth_config['token']}"
            })
    
    def _get_oauth2_token(self) -> str:
        """è·å–OAuth2ä»¤ç‰Œ"""
        token_url = self.auth_config['token_url']
        client_id = self.auth_config['client_id']
        client_secret = self.auth_config['client_secret']
        
        data = {
            'grant_type': 'client_credentials',
            'client_id': client_id,
            'client_secret': client_secret,
            'scope': ' '.join(self.auth_config.get('scopes', []))
        }
        
        response = requests.post(token_url, data=data)
        response.raise_for_status()
        
        token_data = response.json()
        return token_data['access_token']
    
    def get_issue_details(self, issue_key: str) -> Optional[Dict]:
        """è·å–é—®é¢˜è¯¦æƒ…"""
        try:
            url = f"{self.base_url}/rest/api/3/issue/{issue_key}"
            params = {
                'fields': 'summary,description,status,assignee,issuetype,priority'
            }
            
            response = self.session.get(url, params=params)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            self.logger.error(f"Failed to get issue {issue_key} details: {e}")
            return None
    
    def update_issue_status(self, issue_key: str, status: str, 
                          comment: str = None) -> bool:
        """æ›´æ–°é—®é¢˜çŠ¶æ€"""
        try:
            url = f"{self.base_url}/rest/api/3/issue/{issue_key}/transitions"
            
            # è·å–å¯ç”¨çš„è½¬æ¢
            response = self.session.get(url)
            response.raise_for_status()
            transitions = response.json()['transitions']
            
            # æŸ¥æ‰¾ç›®æ ‡çŠ¶æ€çš„è½¬æ¢ID
            transition_id = None
            for transition in transitions:
                if transition['to']['name'].lower() == status.lower():
                    transition_id = transition['id']
                    break
            
            if not transition_id:
                self.logger.error(f"Transition to status '{status}' not found for issue {issue_key}")
                return False
            
            # æ‰§è¡ŒçŠ¶æ€è½¬æ¢
            transition_data = {
                'transition': {
                    'id': transition_id
                }
            }
            
            if comment:
                transition_data['update'] = {
                    'comment': [
                        {
                            'add': {
                                'body': comment
                            }
                        }
                    ]
                }
            
            response = self.session.post(
                f"{self.base_url}/rest/api/3/issue/{issue_key}/transitions",
                json=transition_data
            )
            response.raise_for_status()
            
            self.logger.info(f"Issue {issue_key} status updated to {status}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to update issue {issue_key} status: {e}")
            return False
    
    def create_issue_link(self, issue_key: str, linked_issue_key: str, 
                         link_type: str = "Relates") -> bool:
        """åˆ›å»ºé—®é¢˜é“¾æ¥"""
        try:
            url = f"{self.base_url}/rest/api/3/issueLink"
            
            link_data = {
                'type': {
                    'name': link_type
                },
                'inwardIssue': {
                    'key': issue_key
                },
                'outwardIssue': {
                    'key': linked_issue_key
                }
            }
            
            response = self.session.post(url, json=link_data)
            response.raise_for_status()
            
            self.logger.info(f"Created link between {issue_key} and {linked_issue_key}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to create issue link: {e}")
            return False
    
    def add_deployment_comment(self, issue_key: str, deployment_info: Dict) -> bool:
        """æ·»åŠ éƒ¨ç½²ä¿¡æ¯è¯„è®º"""
        try:
            comment = f"""
**Deployment Information**
- Environment: {deployment_info.get('environment', 'Unknown')}
- Version: {deployment_info.get('version', 'Unknown')}
- Deployed by: {deployment_info.get('deployed_by', 'Unknown')}
- Deployed at: {deployment_info.get('deployed_at', datetime.now().isoformat())}
- Status: {deployment_info.get('status', 'Unknown')}
- Pipeline: {deployment_info.get('pipeline_url', 'N/A')}
            """
            
            url = f"{self.base_url}/rest/api/3/issue/{issue_key}/comment"
            comment_data = {
                'body': comment
            }
            
            response = self.session.post(url, json=comment_data)
            response.raise_for_status()
            
            return True
        except Exception as e:
            self.logger.error(f"Failed to add deployment comment to issue {issue_key}: {e}")
            return False
```

### 2. éœ€æ±‚é©±åŠ¨éƒ¨ç½²

é€šè¿‡ä¸é¡¹ç›®ç®¡ç†å·¥å…·é›†æˆå®ç°éœ€æ±‚é©±åŠ¨çš„è‡ªåŠ¨åŒ–éƒ¨ç½²ï¼š

#### éƒ¨ç½²è§¦å‘æœºåˆ¶
```yaml
# éœ€æ±‚é©±åŠ¨éƒ¨ç½²é…ç½®ç¤ºä¾‹
deployment_triggers:
  jira:
    # åŸºäºé—®é¢˜çŠ¶æ€çš„éƒ¨ç½²è§¦å‘
    issue_status_trigger:
      enabled: true
      issue_types: ["Story", "Bug"]
      target_status: "Ready for Deployment"
      pipeline_mapping:
        "PROJ1": "project1-deployment-pipeline"
        "PROJ2": "project2-deployment-pipeline"
    
    # åŸºäºæ ‡ç­¾çš„éƒ¨ç½²è§¦å‘
    label_trigger:
      enabled: true
      labels: ["deploy-to-prod", "release-candidate"]
      pipeline_mapping:
        "deploy-to-prod": "production-deployment-pipeline"
        "release-candidate": "staging-deployment-pipeline"
    
    # åŸºäºç‰ˆæœ¬çš„éƒ¨ç½²è§¦å‘
    version_trigger:
      enabled: true
      version_pattern: "^v\\d+\\.\\d+\\.\\d+$"
      pipeline_mapping:
        ".*": "version-deployment-pipeline"
```

## ä¸ç›‘æ§ç³»ç»Ÿé›†æˆ

ç›‘æ§ç³»ç»Ÿé›†æˆèƒ½å¤Ÿå®ç°éƒ¨ç½²åçš„è‡ªåŠ¨éªŒè¯å’ŒæŒç»­ç›‘æ§ã€‚

### 1. Prometheusé›†æˆå®è·µ

Prometheusä½œä¸ºäº‘åŸç”Ÿç›‘æ§ç³»ç»Ÿçš„ä»£è¡¨ï¼Œä¸å…¶é›†æˆèƒ½å¤Ÿè·å–ä¸°å¯Œçš„ç›‘æ§æŒ‡æ ‡ã€‚

#### ç›‘æ§æ•°æ®æ”¶é›†
```python
#!/usr/bin/env python3
"""
Prometheusé›†æˆå·¥å…·
å®ç°ä¸Prometheusç›‘æ§ç³»ç»Ÿçš„é›†æˆ
"""

import requests
import json
import logging
from typing import Dict, List, Optional
from datetime import datetime, timedelta

class PrometheusIntegration:
    def __init__(self, prometheus_url: str, auth_config: Dict = None):
        self.prometheus_url = prometheus_url.rstrip('/')
        self.auth_config = auth_config
        self.logger = logging.getLogger(__name__)
        self.session = requests.Session()
        
        if auth_config:
            self._setup_authentication()
    
    def _setup_authentication(self):
        """è®¾ç½®è®¤è¯ä¿¡æ¯"""
        if self.auth_config['type'] == 'basic':
            from requests.auth import HTTPBasicAuth
            self.session.auth = HTTPBasicAuth(
                self.auth_config['username'],
                self.auth_config['password']
            )
        elif self.auth_config['type'] == 'token':
            self.session.headers.update({
                'Authorization': f"Bearer {self.auth_config['token']}"
            })
    
    def query_metric(self, query: str, time: str = None) -> Optional[Dict]:
        """æŸ¥è¯¢æŒ‡æ ‡æ•°æ®"""
        try:
            url = f"{self.prometheus_url}/api/v1/query"
            params = {'query': query}
            
            if time:
                params['time'] = time
            
            response = self.session.get(url, params=params)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            self.logger.error(f"Failed to query metric '{query}': {e}")
            return None
    
    def query_range(self, query: str, start: str, end: str, 
                   step: str = "1m") -> Optional[Dict]:
        """æŸ¥è¯¢æ—¶é—´èŒƒå›´å†…çš„æŒ‡æ ‡æ•°æ®"""
        try:
            url = f"{self.prometheus_url}/api/v1/query_range"
            params = {
                'query': query,
                'start': start,
                'end': end,
                'step': step
            }
            
            response = self.session.get(url, params=params)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            self.logger.error(f"Failed to query range for '{query}': {e}")
            return None
    
    def get_deployment_metrics(self, service_name: str, 
                             start_time: str, end_time: str) -> Dict:
        """è·å–éƒ¨ç½²ç›¸å…³æŒ‡æ ‡"""
        metrics = {}
        
        # æŸ¥è¯¢æœåŠ¡å¯ç”¨æ€§
        availability_query = f'up{{job="{service_name}"}}'
        availability_data = self.query_range(
            availability_query, start_time, end_time
        )
        if availability_data and availability_data.get('status') == 'success':
            metrics['availability'] = self._calculate_availability(availability_data)
        
        # æŸ¥è¯¢å“åº”æ—¶é—´
        latency_query = f'histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{{job="{service_name}"}}[5m])) by (le))'
        latency_data = self.query_range(
            latency_query, start_time, end_time
        )
        if latency_data and latency_data.get('status') == 'success':
            metrics['latency_p95'] = self._extract_metric_values(latency_data)
        
        # æŸ¥è¯¢é”™è¯¯ç‡
        error_rate_query = f'sum(rate(http_requests_total{{job="{service_name}", status=~"5.."}}[5m])) / sum(rate(http_requests_total{{job="{service_name}"}}[5m]))'
        error_rate_data = self.query_range(
            error_rate_query, start_time, end_time
        )
        if error_rate_data and error_rate_data.get('status') == 'success':
            metrics['error_rate'] = self._extract_metric_values(error_rate_data)
        
        return metrics
    
    def _calculate_availability(self, data: Dict) -> float:
        """è®¡ç®—æœåŠ¡å¯ç”¨æ€§"""
        if not data.get('data', {}).get('result'):
            return 0.0
        
        results = data['data']['result']
        if not results:
            return 0.0
        
        # ç®€åŒ–è®¡ç®—ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
        total_points = len(results[0].get('values', []))
        up_points = sum(1 for _, value in results[0].get('values', []) if float(value) == 1.0)
        
        return (up_points / total_points) * 100 if total_points > 0 else 0.0
    
    def _extract_metric_values(self, data: Dict) -> List[Dict]:
        """æå–æŒ‡æ ‡å€¼"""
        values = []
        results = data.get('data', {}).get('result', [])
        
        for result in results:
            metric_labels = result.get('metric', {})
            for timestamp, value in result.get('values', []):
                values.append({
                    'timestamp': datetime.fromtimestamp(float(timestamp)).isoformat(),
                    'value': float(value),
                    'labels': metric_labels
                })
        
        return values
    
    def create_alert(self, alert_config: Dict) -> bool:
        """åˆ›å»ºå‘Šè­¦è§„åˆ™"""
        try:
            # è¿™é‡Œåº”è¯¥ä¸Alertmanageré›†æˆ
            # æˆ–è€…é€šè¿‡æ–‡ä»¶æ–¹å¼ç®¡ç†å‘Šè­¦è§„åˆ™
            alert_rule = {
                'groups': [
                    {
                        'name': alert_config.get('group', 'ci-cd-alerts'),
                        'rules': [
                            {
                                'alert': alert_config['name'],
                                'expr': alert_config['expr'],
                                'for': alert_config.get('for', '5m'),
                                'labels': alert_config.get('labels', {}),
                                'annotations': alert_config.get('annotations', {})
                            }
                        ]
                    }
                ]
            }
            
            # ä¿å­˜å‘Šè­¦è§„åˆ™åˆ°æ–‡ä»¶æˆ–é€šè¿‡APIåˆ›å»º
            rule_file = f"/etc/prometheus/rules/{alert_config['name']}.yml"
            with open(rule_file, 'w') as f:
                yaml.dump(alert_rule, f)
            
            # é‡æ–°åŠ è½½Prometheusé…ç½®
            self._reload_prometheus()
            
            return True
        except Exception as e:
            self.logger.error(f"Failed to create alert: {e}")
            return False
    
    def _reload_prometheus(self):
        """é‡æ–°åŠ è½½Prometheusé…ç½®"""
        try:
            response = self.session.post(f"{self.prometheus_url}/-/reload")
            response.raise_for_status()
        except Exception as e:
            self.logger.error(f"Failed to reload Prometheus: {e}")
```

### 2. éƒ¨ç½²åè‡ªåŠ¨éªŒè¯

é€šè¿‡ç›‘æ§é›†æˆå®ç°éƒ¨ç½²åçš„è‡ªåŠ¨éªŒè¯ï¼š

#### éªŒè¯ç­–ç•¥é…ç½®
```yaml
# éƒ¨ç½²åéªŒè¯é…ç½®
post_deployment_validation:
  metrics_validation:
    - name: "service_availability"
      query: 'up{job="{{service_name}}"}'
      expected_value: 1
      tolerance: 0
      duration: "5m"
      failure_action: "rollback"
    
    - name: "response_time"
      query: 'histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{job="{{service_name}}"})[5m]))'
      max_value: 0.5  # 500ms
      duration: "5m"
      failure_action: "alert"
    
    - name: "error_rate"
      query: 'sum(rate(http_requests_total{job="{{service_name}}", status=~"5.."})[5m]) / sum(rate(http_requests_total{job="{{service_name}}"})[5m])'
      max_value: 0.01  # 1%
      duration: "5m"
      failure_action: "rollback"
  
  health_check_validation:
    http_checks:
      - url: "http://{{service_url}}/health"
        expected_status: 200
        timeout: "30s"
        retries: 3
    
    tcp_checks:
      - host: "{{service_host}}"
        port: "{{service_port}}"
        timeout: "10s"
        retries: 3
  
  rollback_policy:
    enabled: true
    max_failures: 3
    rollback_pipeline: "rollback-{{service_name}}"
```

## ä¸æ²Ÿé€šå·¥å…·é›†æˆ

æ²Ÿé€šå·¥å…·é›†æˆèƒ½å¤Ÿå®ç°åŠæ—¶çš„çŠ¶æ€é€šçŸ¥å’Œå›¢é˜Ÿåä½œã€‚

### 1. Slacké›†æˆå®è·µ

Slackä½œä¸ºå¹¿æ³›ä½¿ç”¨çš„å›¢é˜Ÿæ²Ÿé€šå·¥å…·ï¼Œä¸å…¶é›†æˆèƒ½å¤Ÿå®ç°ä¸°å¯Œçš„é€šçŸ¥åŠŸèƒ½ã€‚

#### é€šçŸ¥æ¶ˆæ¯è®¾è®¡
```python
#!/usr/bin/env python3
"""
Slacké›†æˆå·¥å…·
å®ç°ä¸Slackçš„æ·±åº¦é›†æˆ
"""

import requests
import json
import logging
from typing import Dict, List, Optional
from datetime import datetime

class SlackIntegration:
    def __init__(self, webhook_urls: Dict[str, str], bot_token: str = None):
        self.webhook_urls = webhook_urls
        self.bot_token = bot_token
        self.logger = logging.getLogger(__name__)
        self.session = requests.Session()
        
        if bot_token:
            self.session.headers.update({
                'Authorization': f"Bearer {bot_token}"
            })
    
    def send_build_notification(self, channel: str, build_info: Dict) -> bool:
        """å‘é€æ„å»ºé€šçŸ¥"""
        try:
            webhook_url = self.webhook_urls.get(channel)
            if not webhook_url:
                self.logger.error(f"Webhook URL not found for channel {channel}")
                return False
            
            # æ„å»ºæ¶ˆæ¯å†…å®¹
            message = self._build_build_message(build_info)
            
            response = requests.post(webhook_url, json=message)
            response.raise_for_status()
            
            self.logger.info(f"Build notification sent to channel {channel}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send build notification: {e}")
            return False
    
    def send_deployment_notification(self, channel: str, deployment_info: Dict) -> bool:
        """å‘é€éƒ¨ç½²é€šçŸ¥"""
        try:
            webhook_url = self.webhook_urls.get(channel)
            if not webhook_url:
                self.logger.error(f"Webhook URL not found for channel {channel}")
                return False
            
            # æ„å»ºæ¶ˆæ¯å†…å®¹
            message = self._build_deployment_message(deployment_info)
            
            response = requests.post(webhook_url, json=message)
            response.raise_for_status()
            
            self.logger.info(f"Deployment notification sent to channel {channel}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send deployment notification: {e}")
            return False
    
    def send_alert_notification(self, channel: str, alert_info: Dict) -> bool:
        """å‘é€å‘Šè­¦é€šçŸ¥"""
        try:
            webhook_url = self.webhook_urls.get(channel)
            if not webhook_url:
                self.logger.error(f"Webhook URL not found for channel {channel}")
                return False
            
            # æ„å»ºæ¶ˆæ¯å†…å®¹
            message = self._build_alert_message(alert_info)
            
            response = requests.post(webhook_url, json=message)
            response.raise_for_status()
            
            self.logger.info(f"Alert notification sent to channel {channel}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send alert notification: {e}")
            return False
    
    def _build_build_message(self, build_info: Dict) -> Dict:
        """æ„å»ºæ„å»ºé€šçŸ¥æ¶ˆæ¯"""
        status = build_info.get('status', 'unknown')
        status_emoji = {
            'success': ':white_check_mark:',
            'failed': ':x:',
            'running': ':hourglass_flowing_sand:',
            'cancelled': ':no_entry:'
        }.get(status, ':question:')
        
        status_color = {
            'success': 'good',
            'failed': 'danger',
            'running': 'warning',
            'cancelled': 'warning'
        }.get(status, '#cccccc')
        
        message = {
            'attachments': [
                {
                    'color': status_color,
                    'blocks': [
                        {
                            'type': 'header',
                            'text': {
                                'type': 'plain_text',
                                'text': f'{status_emoji} æ„å»ºé€šçŸ¥ - {build_info.get("project_name", "Unknown")}'
                            }
                        },
                        {
                            'type': 'section',
                            'fields': [
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*æ„å»ºID:*\n{build_info.get("build_id", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*çŠ¶æ€:*\n{status.capitalize()}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*è§¦å‘è€…:*\n{build_info.get("triggered_by", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*åˆ†æ”¯:*\n{build_info.get("branch", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*å¼€å§‹æ—¶é—´:*\n{build_info.get("start_time", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç»“æŸæ—¶é—´:*\n{build_info.get("end_time", "Unknown")}'
                                }
                            ]
                        },
                        {
                            'type': 'actions',
                            'elements': [
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹æ„å»ºè¯¦æƒ…'
                                    },
                                    'url': build_info.get('build_url', '#')
                                }
                            ]
                        }
                    ]
                }
            ]
        }
        
        return message
    
    def _build_deployment_message(self, deployment_info: Dict) -> Dict:
        """æ„å»ºéƒ¨ç½²é€šçŸ¥æ¶ˆæ¯"""
        status = deployment_info.get('status', 'unknown')
        status_emoji = {
            'success': ':rocket:',
            'failed': ':boom:',
            'running': ':hourglass_flowing_sand:',
            'cancelled': ':no_entry:'
        }.get(status, ':question:')
        
        status_color = {
            'success': 'good',
            'failed': 'danger',
            'running': 'warning',
            'cancelled': 'warning'
        }.get(status, '#cccccc')
        
        message = {
            'attachments': [
                {
                    'color': status_color,
                    'blocks': [
                        {
                            'type': 'header',
                            'text': {
                                'type': 'plain_text',
                                'text': f'{status_emoji} éƒ¨ç½²é€šçŸ¥ - {deployment_info.get("service_name", "Unknown")}'
                            }
                        },
                        {
                            'type': 'section',
                            'fields': [
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç¯å¢ƒ:*\n{deployment_info.get("environment", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç‰ˆæœ¬:*\n{deployment_info.get("version", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*éƒ¨ç½²è€…:*\n{deployment_info.get("deployed_by", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*çŠ¶æ€:*\n{status.capitalize()}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*å¼€å§‹æ—¶é—´:*\n{deployment_info.get("start_time", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç»“æŸæ—¶é—´:*\n{deployment_info.get("end_time", "Unknown")}'
                                }
                            ]
                        },
                        {
                            'type': 'actions',
                            'elements': [
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹éƒ¨ç½²è¯¦æƒ…'
                                    },
                                    'url': deployment_info.get('deployment_url', '#')
                                },
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹æœåŠ¡'
                                    },
                                    'url': deployment_info.get('service_url', '#')
                                }
                            ]
                        }
                    ]
                }
            ]
        }
        
        return message
    
    def _build_alert_message(self, alert_info: Dict) -> Dict:
        """æ„å»ºå‘Šè­¦é€šçŸ¥æ¶ˆæ¯"""
        severity = alert_info.get('severity', 'info')
        severity_emoji = {
            'critical': ':rotating_light:',
            'warning': ':warning:',
            'info': ':information_source:'
        }.get(severity, ':information_source:')
        
        severity_color = {
            'critical': 'danger',
            'warning': 'warning',
            'info': 'good'
        }.get(severity, '#cccccc')
        
        message = {
            'attachments': [
                {
                    'color': severity_color,
                    'blocks': [
                        {
                            'type': 'header',
                            'text': {
                                'type': 'plain_text',
                                'text': f'{severity_emoji} {alert_info.get("alert_name", "Unknown Alert")}'
                            }
                        },
                        {
                            'type': 'section',
                            'text': {
                                'type': 'mrkdwn',
                                'text': alert_info.get('description', 'No description provided')
                            }
                        },
                        {
                            'type': 'section',
                            'fields': [
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ä¸¥é‡çº§åˆ«:*\n{severity.capitalize()}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*è§¦å‘æ—¶é—´:*\n{alert_info.get("timestamp", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*æœåŠ¡:*\n{alert_info.get("service", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç¯å¢ƒ:*\n{alert_info.get("environment", "Unknown")}'
                                }
                            ]
                        },
                        {
                            'type': 'actions',
                            'elements': [
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹å‘Šè­¦è¯¦æƒ…'
                                    },
                                    'url': alert_info.get('alert_url', '#')
                                },
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹ç›‘æ§é¢æ¿'
                                    },
                                    'url': alert_info.get('dashboard_url', '#')
                                }
                            ]
                        }
                    ]
                }
            ]
        }
        
        return message
```

### 2. é’‰é’‰é›†æˆå®è·µ

é’ˆå¯¹å›½å†…ç”¨æˆ·ï¼Œä¸é’‰é’‰çš„é›†æˆåŒæ ·é‡è¦ï¼š

#### é’‰é’‰æœºå™¨äººé›†æˆ
```python
#!/usr/bin/env python3
"""
é’‰é’‰é›†æˆå·¥å…·
å®ç°ä¸é’‰é’‰çš„æ·±åº¦é›†æˆ
"""

import requests
import json
import hmac
import hashlib
import base64
import urllib.parse
import time
import logging
from typing import Dict, Any

class DingtalkIntegration:
    def __init__(self, webhook_url: str, secret: str = None):
        self.webhook_url = webhook_url
        self.secret = secret
        self.logger = logging.getLogger(__name__)
    
    def _generate_sign(self) -> tuple:
        """ç”Ÿæˆç­¾å"""
        if not self.secret:
            return "", ""
        
        timestamp = str(round(time.time() * 1000))
        secret_enc = self.secret.encode('utf-8')
        string_to_sign = '{}\n{}'.format(timestamp, self.secret)
        string_to_sign_enc = string_to_sign.encode('utf-8')
        hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()
        sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
        return timestamp, sign
    
    def send_message(self, message: Dict[str, Any]) -> bool:
        """å‘é€æ¶ˆæ¯"""
        try:
            # æ„å»ºè¯·æ±‚URL
            url = self.webhook_url
            if self.secret:
                timestamp, sign = self._generate_sign()
                url = f"{self.webhook_url}&timestamp={timestamp}&sign={sign}"
            
            # å‘é€è¯·æ±‚
            response = requests.post(url, json=message)
            response.raise_for_status()
            
            result = response.json()
            if result.get('errcode') != 0:
                self.logger.error(f"Failed to send Dingtalk message: {result}")
                return False
            
            self.logger.info("Dingtalk message sent successfully")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send Dingtalk message: {e}")
            return False
    
    def send_build_notification(self, build_info: Dict) -> bool:
        """å‘é€æ„å»ºé€šçŸ¥"""
        status = build_info.get('status', 'unknown')
        status_emoji = {
            'success': 'âœ…',
            'failed': 'âŒ',
            'running': 'â³',
            'cancelled': 'ğŸš«'
        }.get(status, 'â“')
        
        message = {
            "msgtype": "markdown",
            "markdown": {
                "title": f"æ„å»ºé€šçŸ¥ - {build_info.get('project_name', 'Unknown')}",
                "text": f"""## {status_emoji} æ„å»ºé€šçŸ¥\n\n**é¡¹ç›®åç§°**: {build_info.get('project_name', 'Unknown')}\n\n**æ„å»ºID**: {build_info.get('build_id', 'Unknown')}\n\n**çŠ¶æ€**: {status.capitalize()}\n\n**è§¦å‘è€…**: {build_info.get('triggered_by', 'Unknown')}\n\n**åˆ†æ”¯**: {build_info.get('branch', 'Unknown')}\n\n**å¼€å§‹æ—¶é—´**: {build_info.get('start_time', 'Unknown')}\n\n**ç»“æŸæ—¶é—´**: {build_info.get('end_time', 'Unknown')}\n\n[æŸ¥çœ‹æ„å»ºè¯¦æƒ…]({build_info.get('build_url', '#')})"""
            }
        }
        
        return self.send_message(message)
    
    def send_deployment_notification(self, deployment_info: Dict) -> bool:
        """å‘é€éƒ¨ç½²é€šçŸ¥"""
        status = deployment_info.get('status', 'unknown')
        status_emoji = {
            'success': 'ğŸš€',
            'failed': 'ğŸ’¥',
            'running': 'â³',
            'cancelled': 'ğŸš«'
        }.get(status, 'â“')
        
        message = {
            "msgtype": "markdown",
            "markdown": {
                "title": f"éƒ¨ç½²é€šçŸ¥ - {deployment_info.get('service_name', 'Unknown')}",
                "text": f"""## {status_emoji} éƒ¨ç½²é€šçŸ¥\n\n**æœåŠ¡åç§°**: {deployment_info.get('service_name', 'Unknown')}\n\n**ç¯å¢ƒ**: {deployment_info.get('environment', 'Unknown')}\n\n**ç‰ˆæœ¬**: {deployment_info.get('version', 'Unknown')}\n\n**éƒ¨ç½²è€…**: {deployment_info.get('deployed_by', 'Unknown')}\n\n**çŠ¶æ€**: {status.capitalize()}\n\n**å¼€å§‹æ—¶é—´**: {deployment_info.get('start_time', 'Unknown')}\n\n**ç»“æŸæ—¶é—´**: {deployment_info.get('end_time', 'Unknown')}\n\n[æŸ¥çœ‹éƒ¨ç½²è¯¦æƒ…]({deployment_info.get('deployment_url', '#')}) | [æŸ¥çœ‹æœåŠ¡]({deployment_info.get('service_url', '#')})"""
            }
        }
        
        return self.send_message(message)
    
    def send_alert_notification(self, alert_info: Dict) -> bool:
        """å‘é€å‘Šè­¦é€šçŸ¥"""
        severity = alert_info.get('severity', 'info')
        severity_emoji = {
            'critical': 'ğŸš¨',
            'warning': 'âš ï¸',
            'info': 'â„¹ï¸'
        }.get(severity, 'â„¹ï¸')
        
        message = {
            "msgtype": "markdown",
            "markdown": {
                "title": f"{severity_emoji} {alert_info.get('alert_name', 'Unknown Alert')}",
                "text": f"""## {severity_emoji} {alert_info.get('alert_name', 'Unknown Alert')}\n\n{alert_info.get('description', 'No description provided')}\n\n**ä¸¥é‡çº§åˆ«**: {severity.capitalize()}\n\n**è§¦å‘æ—¶é—´**: {alert_info.get('timestamp', 'Unknown')}\n\n**æœåŠ¡**: {alert_info.get('service', 'Unknown')}\n\n**ç¯å¢ƒ**: {alert_info.get('environment', 'Unknown')}\n\n[æŸ¥çœ‹å‘Šè­¦è¯¦æƒ…]({alert_info.get('alert_url', '#')}) | [æŸ¥çœ‹ç›‘æ§é¢æ¿]({alert_info.get('dashboard_url', '#')})"""
            }
        }
        
        return self.send_message(message)
```

é€šè¿‡ä¸é¡¹ç›®ç®¡ç†å·¥å…·ã€ç›‘æ§ç³»ç»Ÿå’Œæ²Ÿé€šå·¥å…·çš„æ·±åº¦é›†æˆï¼ŒCI/CDå¹³å°èƒ½å¤Ÿå®ç°ç«¯åˆ°ç«¯çš„è‡ªåŠ¨åŒ–æµç¨‹ï¼Œæå‡å›¢é˜Ÿåä½œæ•ˆç‡ï¼Œå¢å¼ºç³»ç»Ÿå¯è§‚æµ‹æ€§ï¼Œå¹¶ç¡®ä¿è½¯ä»¶äº¤ä»˜çš„é«˜è´¨é‡ã€‚å…³é”®æ˜¯è¦æ ¹æ®ç»„ç»‡çš„å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„é›†æˆæ–¹æ¡ˆï¼Œè®¾è®¡åˆç†çš„é›†æˆæ¶æ„ï¼Œå¹¶å»ºç«‹å®Œå–„çš„ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶ã€‚