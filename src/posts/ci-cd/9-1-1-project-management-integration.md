---
title: "ä¸é¡¹ç›®ç®¡ç†å·¥å…·é›†æˆ: éœ€æ±‚é©±åŠ¨éƒ¨ç½²"
date: 2025-08-30
categories: [CICD]
tags: [ci,cd,project-management,jira,azure-devops,devops,requirements]
published: true
---
åœ¨ç°ä»£è½¯ä»¶å¼€å‘å®è·µä¸­ï¼ŒCI/CDå¹³å°ä¸é¡¹ç›®ç®¡ç†å·¥å…·çš„é›†æˆå·²æˆä¸ºæå‡ç ”å‘æ•ˆç‡å’Œç¡®ä¿äº¤ä»˜è´¨é‡çš„å…³é”®ç¯èŠ‚ã€‚é€šè¿‡å°†ä»£ç æäº¤ã€æ„å»ºã€æµ‹è¯•ã€éƒ¨ç½²ç­‰æŠ€æœ¯æ´»åŠ¨ä¸éœ€æ±‚ç®¡ç†ã€ç¼ºé™·è·Ÿè¸ªã€ä»»åŠ¡åˆ†é…ç­‰ä¸šåŠ¡æ´»åŠ¨å…³è”èµ·æ¥ï¼Œå›¢é˜Ÿèƒ½å¤Ÿå®ç°éœ€æ±‚é©±åŠ¨çš„éƒ¨ç½²ï¼Œç¡®ä¿æ¯ä¸€æ¬¡ä»£ç å˜æ›´éƒ½èƒ½è¿½æº¯åˆ°å…·ä½“çš„ä¸šåŠ¡éœ€æ±‚æˆ–é—®é¢˜ä¿®å¤ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å¦‚ä½•å®ç°CI/CDå¹³å°ä¸ä¸»æµé¡¹ç›®ç®¡ç†å·¥å…·çš„æ·±åº¦é›†æˆã€‚

## é¡¹ç›®ç®¡ç†å·¥å…·é›†æˆçš„ä»·å€¼

é¡¹ç›®ç®¡ç†å·¥å…·é›†æˆä¸ä»…èƒ½å¤Ÿæå‡å›¢é˜Ÿåä½œæ•ˆç‡ï¼Œè¿˜èƒ½å¢å¼ºè½¯ä»¶äº¤ä»˜è¿‡ç¨‹çš„é€æ˜åº¦å’Œå¯è¿½æº¯æ€§ã€‚

### 1. éœ€æ±‚å¯è¿½æº¯æ€§

é€šè¿‡é›†æˆå®ç°ä»éœ€æ±‚åˆ°ä»£ç çš„å®Œæ•´è¿½æº¯é“¾ï¼š
- **éœ€æ±‚å…³è”**ï¼šå°†ä»£ç æäº¤ä¸å…·ä½“çš„éœ€æ±‚æˆ–ç”¨æˆ·æ•…äº‹å…³è”
- **å˜æ›´è·Ÿè¸ª**ï¼šè·Ÿè¸ªæ¯ä¸ªéœ€æ±‚ç›¸å…³çš„ä»£ç å˜æ›´å†å²
- **çŠ¶æ€åŒæ­¥**ï¼šè‡ªåŠ¨æ›´æ–°éœ€æ±‚åœ¨ä¸åŒé˜¶æ®µçš„çŠ¶æ€
- **å½±å“åˆ†æ**ï¼šåˆ†æéœ€æ±‚å˜æ›´å¯¹ç³»ç»Ÿå…¶ä»–éƒ¨åˆ†çš„å½±å“

### 2. è‡ªåŠ¨åŒ–å·¥ä½œæµ

å»ºç«‹è‡ªåŠ¨åŒ–çš„å·¥ä½œæµå‡å°‘æ‰‹åŠ¨æ“ä½œï¼š
- **è‡ªåŠ¨åˆ›å»ºä»»åŠ¡**ï¼šæ ¹æ®ä»£ç æäº¤è‡ªåŠ¨åˆ›å»ºç›¸å…³ä»»åŠ¡
- **çŠ¶æ€è‡ªåŠ¨æ›´æ–°**ï¼šæ ¹æ®æ„å»ºå’Œéƒ¨ç½²ç»“æœè‡ªåŠ¨æ›´æ–°ä»»åŠ¡çŠ¶æ€
- **é€šçŸ¥æœºåˆ¶**ï¼šåŠæ—¶é€šçŸ¥ç›¸å…³äººå‘˜ä»»åŠ¡çŠ¶æ€å˜æ›´
- **å®¡æ‰¹æµç¨‹**ï¼šé›†æˆå®¡æ‰¹æµç¨‹ç¡®ä¿å˜æ›´åˆè§„æ€§

### 3. æ•°æ®é©±åŠ¨å†³ç­–

é€šè¿‡é›†æˆè·å–ä¸°å¯Œçš„æ•°æ®æ”¯æŒå†³ç­–ï¼š
- **äº¤ä»˜æ•ˆç‡åˆ†æ**ï¼šåˆ†æä»éœ€æ±‚æå‡ºåˆ°åŠŸèƒ½ä¸Šçº¿çš„å‘¨æœŸ
- **è´¨é‡æŒ‡æ ‡è·Ÿè¸ª**ï¼šè·Ÿè¸ªç¼ºé™·ä¿®å¤æ•ˆç‡å’Œå¼•å…¥ç‡
- **èµ„æºåˆ©ç”¨ç‡**ï¼šåˆ†æå›¢é˜Ÿå’Œèµ„æºçš„åˆ©ç”¨æƒ…å†µ
- **é£é™©è¯†åˆ«**ï¼šè¯†åˆ«é¡¹ç›®ä¸­çš„æ½œåœ¨é£é™©å’Œç“¶é¢ˆ

## Jiraé›†æˆå®è·µ

Jiraä½œä¸ºAtlassianå…¬å¸å¼€å‘çš„é¡¹ç›®ç®¡ç†å·¥å…·ï¼Œåœ¨ä¼ä¸šä¸­å¹¿æ³›ä½¿ç”¨ã€‚ä¸å…¶æ·±åº¦é›†æˆèƒ½å¤Ÿå®ç°ä¸°å¯Œçš„åŠŸèƒ½ã€‚

### 1. è®¤è¯ä¸è¿æ¥é…ç½®

å®‰å…¨å¯é çš„è®¤è¯æœºåˆ¶æ˜¯é›†æˆçš„åŸºç¡€ï¼š

#### OAuth2è®¤è¯é…ç½®
```yaml
# Jira OAuth2è®¤è¯é…ç½®
jira_integration:
  enabled: true
  base_url: "https://your-company.atlassian.net"
  auth:
    type: "oauth2"
    client_id: "ci-cd-platform-client"
    client_secret: "${JIRA_CLIENT_SECRET}"
    token_url: "https://auth.atlassian.com/oauth/token"
    scopes:
      - "read:jira-work"
      - "write:jira-work"
      - "manage:jira-webhook"
  webhook:
    enabled: true
    events:
      - "jira:issue_created"
      - "jira:issue_updated"
      - "jira:issue_deleted"
```

#### åŸºæœ¬è®¤è¯é…ç½®
```python
#!/usr/bin/env python3
"""
Jiraé›†æˆå·¥å…·
å®ç°ä¸Jiraç³»ç»Ÿçš„æ·±åº¦é›†æˆ
"""

import requests
import json
import logging
from typing import Dict, List, Optional
from datetime import datetime
from requests.auth import HTTPBasicAuth

class JiraIntegration:
    def __init__(self, config: Dict):
        self.config = config
        self.base_url = config['base_url'].rstrip('/')
        self.logger = logging.getLogger(__name__)
        self.session = requests.Session()
        self._setup_authentication()
    
    def _setup_authentication(self):
        """è®¾ç½®è®¤è¯ä¿¡æ¯"""
        auth_config = self.config['auth']
        
        if auth_config['type'] == 'oauth2':
            # OAuth2è®¤è¯
            token = self._get_oauth2_token()
            self.session.headers.update({
                'Authorization': f"Bearer {token}"
            })
        elif auth_config['type'] == 'basic':
            # åŸºæœ¬è®¤è¯
            self.session.auth = HTTPBasicAuth(
                auth_config['username'],
                auth_config['password']
            )
        elif auth_config['type'] == 'token':
            # APIä»¤ç‰Œè®¤è¯
            self.session.headers.update({
                'Authorization': f"Bearer {auth_config['token']}"
            })
    
    def _get_oauth2_token(self) -> str:
        """è·å–OAuth2è®¿é—®ä»¤ç‰Œ"""
        auth_config = self.config['auth']
        token_url = auth_config['token_url']
        
        data = {
            'grant_type': 'client_credentials',
            'client_id': auth_config['client_id'],
            'client_secret': auth_config['client_secret'],
            'scope': ' '.join(auth_config.get('scopes', []))
        }
        
        try:
            response = requests.post(token_url, data=data)
            response.raise_for_status()
            token_data = response.json()
            return token_data['access_token']
        except Exception as e:
            self.logger.error(f"Failed to get OAuth2 token: {e}")
            raise
    
    def get_issue(self, issue_key: str) -> Optional[Dict]:
        """è·å–é—®é¢˜è¯¦æƒ…"""
        try:
            url = f"{self.base_url}/rest/api/3/issue/{issue_key}"
            params = {
                'fields': 'summary,description,status,assignee,issuetype,priority,project'
            }
            
            response = self.session.get(url, params=params)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            self.logger.error(f"Failed to get issue {issue_key}: {e}")
            return None
    
    def search_issues(self, jql: str, max_results: int = 50) -> Optional[Dict]:
        """æœç´¢é—®é¢˜"""
        try:
            url = f"{self.base_url}/rest/api/3/search"
            params = {
                'jql': jql,
                'maxResults': max_results,
                'fields': 'summary,status,assignee,issuetype,project'
            }
            
            response = self.session.get(url, params=params)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            self.logger.error(f"Failed to search issues with JQL '{jql}': {e}")
            return None
```

### 2. éœ€æ±‚å…³è”å®ç°

å°†ä»£ç æäº¤ä¸Jiraé—®é¢˜è¿›è¡Œå…³è”ï¼š

#### æäº¤ä¿¡æ¯è§£æ
```python
#!/usr/bin/env python3
"""
æäº¤ä¿¡æ¯è§£æå·¥å…·
è§£æGitæäº¤ä¿¡æ¯ä¸­çš„Jiraé—®é¢˜å¼•ç”¨
"""

import re
import logging
from typing import List, Dict

class CommitMessageParser:
    def __init__(self, project_keys: List[str]):
        self.project_keys = project_keys
        self.logger = logging.getLogger(__name__)
        # æ„å»ºæ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼
        project_pattern = '|'.join(project_keys)
        self.issue_pattern = re.compile(
            rf'({project_pattern})-(\d+)',
            re.IGNORECASE
        )
    
    def extract_issue_keys(self, commit_message: str) -> List[str]:
        """ä»æäº¤ä¿¡æ¯ä¸­æå–é—®é¢˜é”®"""
        matches = self.issue_pattern.findall(commit_message)
        issue_keys = [f"{match[0].upper()}-{match[1]}" for match in matches]
        return list(set(issue_keys))  # å»é‡
    
    def parse_commit(self, commit_info: Dict) -> Dict:
        """è§£ææäº¤ä¿¡æ¯"""
        commit_message = commit_info.get('message', '')
        issue_keys = self.extract_issue_keys(commit_message)
        
        return {
            'commit_id': commit_info.get('id'),
            'author': commit_info.get('author'),
            'message': commit_message,
            'issue_keys': issue_keys,
            'timestamp': commit_info.get('timestamp')
        }

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # é…ç½®é¡¹ç›®é”®
    project_keys = ["PROJ", "TASK", "BUG"]
    parser = CommitMessageParser(project_keys)
    
    # æµ‹è¯•æäº¤ä¿¡æ¯
    test_commits = [
        {
            'id': 'abc123',
            'author': 'developer@example.com',
            'message': 'PROJ-123: Implement user authentication feature',
            'timestamp': '2025-08-30T10:30:00Z'
        },
        {
            'id': 'def456',
            'author': 'tester@example.com',
            'message': 'Fix BUG-456: Resolve login timeout issue\n\nAlso addresses TASK-789',
            'timestamp': '2025-08-30T11:15:00Z'
        }
    ]
    
    for commit in test_commits:
        parsed = parser.parse_commit(commit)
        print(f"Commit {parsed['commit_id']}:")
        print(f"  Issues: {parsed['issue_keys']}")
        print(f"  Message: {parsed['message']}")
```

#### è‡ªåŠ¨åŒ–å…³è”å®ç°
```python
#!/usr/bin/env python3
"""
è‡ªåŠ¨åŒ–å…³è”å·¥å…·
å°†ä»£ç æäº¤ä¸Jiraé—®é¢˜è‡ªåŠ¨å…³è”
"""

import logging
from typing import List, Dict
from jira_integration import JiraIntegration
from commit_message_parser import CommitMessageParser

class AutoLinker:
    def __init__(self, jira_client: JiraIntegration, parser: CommitMessageParser):
        self.jira_client = jira_client
        self.parser = parser
        self.logger = logging.getLogger(__name__)
    
    def link_commit_to_issues(self, commit_info: Dict) -> List[Dict]:
        """å°†æäº¤å…³è”åˆ°é—®é¢˜"""
        parsed_commit = self.parser.parse_commit(commit_info)
        issue_keys = parsed_commit['issue_keys']
        
        if not issue_keys:
            self.logger.info(f"No issues found in commit {parsed_commit['commit_id']}")
            return []
        
        linked_issues = []
        for issue_key in issue_keys:
            # è·å–é—®é¢˜è¯¦æƒ…
            issue = self.jira_client.get_issue(issue_key)
            if not issue:
                self.logger.warning(f"Failed to get issue {issue_key}")
                continue
            
            # åˆ›å»ºè¿œç¨‹é“¾æ¥
            link_data = {
                'globalId': f"git-commit:{parsed_commit['commit_id']}",
                'application': {
                    'type': 'git',
                    'name': 'CI/CD Platform'
                },
                'relationship': 'is implemented by',
                'object': {
                    'url': f"https://your-git-server.com/commit/{parsed_commit['commit_id']}",
                    'title': f"Commit: {parsed_commit['commit_id'][:8]}",
                    'summary': parsed_commit['message']
                }
            }
            
            if self._create_remote_link(issue_key, link_data):
                linked_issues.append({
                    'issue_key': issue_key,
                    'issue_summary': issue['fields']['summary'],
                    'commit_id': parsed_commit['commit_id']
                })
                self.logger.info(f"Linked commit {parsed_commit['commit_id']} to issue {issue_key}")
        
        return linked_issues
    
    def _create_remote_link(self, issue_key: str, link_data: Dict) -> bool:
        """åˆ›å»ºè¿œç¨‹é“¾æ¥"""
        try:
            url = f"{self.jira_client.base_url}/rest/api/3/issue/{issue_key}/remotelink"
            response = self.jira_client.session.post(url, json=link_data)
            response.raise_for_status()
            return True
        except Exception as e:
            self.logger.error(f"Failed to create remote link for {issue_key}: {e}")
            return False
    
    def add_development_panel_entry(self, issue_key: str, commit_info: Dict) -> bool:
        """æ·»åŠ å¼€å‘é¢æ¿æ¡ç›®"""
        try:
            # æ³¨æ„ï¼šè¿™éœ€è¦å®‰è£…Development Panelæ’ä»¶æˆ–ä½¿ç”¨ç›¸åº”çš„API
            panel_data = {
                'issueKey': issue_key,
                'repository': 'main-repo',
                'branch': commit_info.get('branch', 'main'),
                'commits': [
                    {
                        'id': commit_info['id'],
                        'author': commit_info['author'],
                        'message': commit_info['message'],
                        'timestamp': commit_info['timestamp'],
                        'url': f"https://your-git-server.com/commit/{commit_info['id']}"
                    }
                ]
            }
            
            # è¿™é‡Œéœ€è¦æ ¹æ®å®é™…ä½¿ç”¨çš„æ’ä»¶è°ƒæ•´APIç«¯ç‚¹
            url = f"{self.jira_client.base_url}/rest/dev-status/1.0/issue/update"
            response = self.jira_client.session.post(url, json=panel_data)
            response.raise_for_status()
            
            self.logger.info(f"Added development panel entry for {issue_key}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to add development panel entry for {issue_key}: {e}")
            return False
```

### 3. çŠ¶æ€åŒæ­¥æœºåˆ¶

æ ¹æ®CI/CDæµç¨‹ç»“æœè‡ªåŠ¨æ›´æ–°Jiraé—®é¢˜çŠ¶æ€ï¼š

#### æ„å»ºçŠ¶æ€åŒæ­¥
```python
#!/usr/bin/env python3
"""
æ„å»ºçŠ¶æ€åŒæ­¥å·¥å…·
å°†æ„å»ºçŠ¶æ€åŒæ­¥åˆ°Jiraé—®é¢˜
"""

import logging
from typing import Dict
from jira_integration import JiraIntegration

class BuildStatusSync:
    def __init__(self, jira_client: JiraIntegration):
        self.jira_client = jira_client
        self.logger = logging.getLogger(__name__)
    
    def update_issue_with_build_status(self, issue_key: str, build_info: Dict) -> bool:
        """æ›´æ–°é—®é¢˜çš„æ„å»ºçŠ¶æ€"""
        try:
            # æ·»åŠ è¯„è®º
            comment = self._generate_build_comment(build_info)
            if not self._add_comment(issue_key, comment):
                return False
            
            # æ›´æ–°è‡ªå®šä¹‰å­—æ®µï¼ˆå¦‚æœé…ç½®äº†ï¼‰
            custom_fields = self._get_build_status_fields(build_info)
            if custom_fields:
                if not self._update_custom_fields(issue_key, custom_fields):
                    return False
            
            self.logger.info(f"Updated build status for issue {issue_key}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to update build status for {issue_key}: {e}")
            return False
    
    def _generate_build_comment(self, build_info: Dict) -> str:
        """ç”Ÿæˆæ„å»ºçŠ¶æ€è¯„è®º"""
        status_emoji = {
            'success': 'âœ…',
            'failed': 'âŒ',
            'running': 'â³',
            'cancelled': 'ğŸš«'
        }.get(build_info.get('status', 'unknown'), 'â“')
        
        status_text = build_info.get('status', 'unknown').capitalize()
        
        comment = f"""
{status_emoji} **Build Status Update**

- **Build ID**: {build_info.get('build_id', 'Unknown')}
- **Status**: {status_text}
- **Branch**: {build_info.get('branch', 'Unknown')}
- **Triggered by**: {build_info.get('triggered_by', 'Unknown')}
- **Start time**: {build_info.get('start_time', 'Unknown')}
- **End time**: {build_info.get('end_time', 'Unknown')}
- **Duration**: {build_info.get('duration', 'Unknown')}

[View Build Details]({build_info.get('build_url', '#')})
        """
        
        return comment.strip()
    
    def _add_comment(self, issue_key: str, comment: str) -> bool:
        """æ·»åŠ è¯„è®ºåˆ°é—®é¢˜"""
        try:
            url = f"{self.jira_client.base_url}/rest/api/3/issue/{issue_key}/comment"
            comment_data = {
                'body': comment
            }
            
            response = self.jira_client.session.post(url, json=comment_data)
            response.raise_for_status()
            return True
        except Exception as e:
            self.logger.error(f"Failed to add comment to {issue_key}: {e}")
            return False
    
    def _get_build_status_fields(self, build_info: Dict) -> Dict:
        """è·å–æ„å»ºçŠ¶æ€è‡ªå®šä¹‰å­—æ®µ"""
        # è¿™é‡Œéœ€è¦æ ¹æ®å®é™…çš„Jiraé…ç½®è°ƒæ•´
        return {
            'customfield_10001': build_info.get('build_id'),  # å‡è®¾çš„æ„å»ºIDå­—æ®µ
            'customfield_10002': build_info.get('status'),    # å‡è®¾çš„æ„å»ºçŠ¶æ€å­—æ®µ
            'customfield_10003': build_info.get('build_url') # å‡è®¾çš„æ„å»ºé“¾æ¥å­—æ®µ
        }
    
    def _update_custom_fields(self, issue_key: str, fields: Dict) -> bool:
        """æ›´æ–°è‡ªå®šä¹‰å­—æ®µ"""
        try:
            url = f"{self.jira_client.base_url}/rest/api/3/issue/{issue_key}"
            update_data = {
                'fields': fields
            }
            
            response = self.jira_client.session.put(url, json=update_data)
            response.raise_for_status()
            return True
        except Exception as e:
            self.logger.error(f"Failed to update custom fields for {issue_key}: {e}")
            return False
```

#### éƒ¨ç½²çŠ¶æ€åŒæ­¥
```python
#!/usr/bin/env python3
"""
éƒ¨ç½²çŠ¶æ€åŒæ­¥å·¥å…·
å°†éƒ¨ç½²çŠ¶æ€åŒæ­¥åˆ°Jiraé—®é¢˜
"""

import logging
from typing import Dict
from jira_integration import JiraIntegration

class DeploymentStatusSync:
    def __init__(self, jira_client: JiraIntegration):
        self.jira_client = jira_client
        self.logger = logging.getLogger(__name__)
    
    def update_issue_with_deployment_status(self, issue_key: str, deployment_info: Dict) -> bool:
        """æ›´æ–°é—®é¢˜çš„éƒ¨ç½²çŠ¶æ€"""
        try:
            # æ·»åŠ éƒ¨ç½²è¯„è®º
            comment = self._generate_deployment_comment(deployment_info)
            if not self._add_comment(issue_key, comment):
                return False
            
            # æ ¹æ®éƒ¨ç½²ç»“æœæ›´æ–°é—®é¢˜çŠ¶æ€
            if deployment_info.get('status') == 'success':
                self._transition_issue_to_deployed(issue_key, deployment_info)
            elif deployment_info.get('status') == 'failed':
                self._transition_issue_to_failed(issue_key, deployment_info)
            
            # æ›´æ–°è‡ªå®šä¹‰å­—æ®µ
            custom_fields = self._get_deployment_fields(deployment_info)
            if custom_fields:
                self._update_custom_fields(issue_key, custom_fields)
            
            self.logger.info(f"Updated deployment status for issue {issue_key}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to update deployment status for {issue_key}: {e}")
            return False
    
    def _generate_deployment_comment(self, deployment_info: Dict) -> str:
        """ç”Ÿæˆéƒ¨ç½²çŠ¶æ€è¯„è®º"""
        status_emoji = {
            'success': 'ğŸš€',
            'failed': 'ğŸ’¥',
            'running': 'â³',
            'cancelled': 'ğŸš«'
        }.get(deployment_info.get('status', 'unknown'), 'â“')
        
        status_text = deployment_info.get('status', 'unknown').capitalize()
        
        comment = f"""
{status_emoji} **Deployment Status Update**

- **Environment**: {deployment_info.get('environment', 'Unknown')}
- **Service**: {deployment_info.get('service_name', 'Unknown')}
- **Version**: {deployment_info.get('version', 'Unknown')}
- **Status**: {status_text}
- **Deployed by**: {deployment_info.get('deployed_by', 'Unknown')}
- **Start time**: {deployment_info.get('start_time', 'Unknown')}
- **End time**: {deployment_info.get('end_time', 'Unknown')}
- **Duration**: {deployment_info.get('duration', 'Unknown')}

[View Deployment Details]({deployment_info.get('deployment_url', '#')})
[Access Service]({deployment_info.get('service_url', '#')})
        """
        
        return comment.strip()
    
    def _add_comment(self, issue_key: str, comment: str) -> bool:
        """æ·»åŠ è¯„è®ºåˆ°é—®é¢˜"""
        try:
            url = f"{self.jira_client.base_url}/rest/api/3/issue/{issue_key}/comment"
            comment_data = {
                'body': comment
            }
            
            response = self.jira_client.session.post(url, json=comment_data)
            response.raise_for_status()
            return True
        except Exception as e:
            self.logger.error(f"Failed to add comment to {issue_key}: {e}")
            return False
    
    def _transition_issue_to_deployed(self, issue_key: str, deployment_info: Dict):
        """å°†é—®é¢˜è½¬æ¢ä¸ºå·²éƒ¨ç½²çŠ¶æ€"""
        try:
            # è·å–å¯ç”¨çš„çŠ¶æ€è½¬æ¢
            transitions_url = f"{self.jira_client.base_url}/rest/api/3/issue/{issue_key}/transitions"
            response = self.jira_client.session.get(transitions_url)
            response.raise_for_status()
            
            transitions = response.json().get('transitions', [])
            
            # æŸ¥æ‰¾"Deployed"æˆ–ç±»ä¼¼çš„çŠ¶æ€è½¬æ¢
            deployed_transition = None
            for transition in transitions:
                if transition['to']['name'].lower() in ['deployed', 'done', 'closed']:
                    deployed_transition = transition
                    break
            
            if deployed_transition:
                # æ‰§è¡ŒçŠ¶æ€è½¬æ¢
                transition_url = f"{self.jira_client.base_url}/rest/api/3/issue/{issue_key}/transitions"
                transition_data = {
                    'transition': {
                        'id': deployed_transition['id']
                    },
                    'update': {
                        'comment': [
                            {
                                'add': {
                                    'body': f"Automatically transitioned to {deployed_transition['to']['name']} after successful deployment to {deployment_info.get('environment', 'Unknown')}"
                                }
                            }
                        ]
                    }
                }
                
                response = self.jira_client.session.post(transition_url, json=transition_data)
                response.raise_for_status()
                
                self.logger.info(f"Transitioned issue {issue_key} to {deployed_transition['to']['name']}")
        except Exception as e:
            self.logger.error(f"Failed to transition issue {issue_key}: {e}")
    
    def _transition_issue_to_failed(self, issue_key: str, deployment_info: Dict):
        """å°†é—®é¢˜è½¬æ¢ä¸ºå¤±è´¥çŠ¶æ€"""
        try:
            # æ·»åŠ å¤±è´¥åŸå› åˆ°è¯„è®º
            failure_comment = f"""
âš ï¸ **Deployment Failed**

The deployment to {deployment_info.get('environment', 'Unknown')} failed.

**Error Details:**
{deployment_info.get('error_message', 'No error details provided')}

[View Deployment Logs]({deployment_info.get('logs_url', '#')})
            """
            
            self._add_comment(issue_key, failure_comment)
            
            # å¯ä»¥é€‰æ‹©å°†é—®é¢˜è½¬æ¢ä¸º"In Progress"æˆ–å…¶ä»–é€‚å½“çŠ¶æ€
            # å…·ä½“å®ç°å–å†³äºå›¢é˜Ÿçš„å·¥ä½œæµé…ç½®
            
        except Exception as e:
            self.logger.error(f"Failed to handle deployment failure for {issue_key}: {e}")
    
    def _get_deployment_fields(self, deployment_info: Dict) -> Dict:
        """è·å–éƒ¨ç½²çŠ¶æ€è‡ªå®šä¹‰å­—æ®µ"""
        return {
            'customfield_10011': deployment_info.get('environment'),     # å‡è®¾çš„ç¯å¢ƒå­—æ®µ
            'customfield_10012': deployment_info.get('version'),        # å‡è®¾çš„ç‰ˆæœ¬å­—æ®µ
            'customfield_10013': deployment_info.get('deployment_url'), # å‡è®¾çš„éƒ¨ç½²é“¾æ¥å­—æ®µ
            'customfield_10014': deployment_info.get('status')          # å‡è®¾çš„éƒ¨ç½²çŠ¶æ€å­—æ®µ
        }
    
    def _update_custom_fields(self, issue_key: str, fields: Dict) -> bool:
        """æ›´æ–°è‡ªå®šä¹‰å­—æ®µ"""
        try:
            url = f"{self.jira_client.base_url}/rest/api/3/issue/{issue_key}"
            update_data = {
                'fields': {k: v for k, v in fields.items() if v is not None}
            }
            
            response = self.jira_client.session.put(url, json=update_data)
            response.raise_for_status()
            return True
        except Exception as e:
            self.logger.error(f"Failed to update custom fields for {issue_key}: {e}")
            return False
```

## Azure DevOpsé›†æˆå®è·µ

é™¤äº†Jiraï¼ŒAzure DevOpsä¹Ÿæ˜¯å¹¿æ³›ä½¿ç”¨çš„ä¼ä¸šçº§é¡¹ç›®ç®¡ç†å·¥å…·ã€‚

### 1. è®¤è¯é…ç½®

Azure DevOpsæ”¯æŒå¤šç§è®¤è¯æ–¹å¼ï¼š

#### ä¸ªäººè®¿é—®ä»¤ç‰Œ(PAT)è®¤è¯
```yaml
# Azure DevOpsé›†æˆé…ç½®
azure_devops_integration:
  enabled: true
  base_url: "https://dev.azure.com/your-organization"
  auth:
    type: "pat"
    token: "${AZURE_DEVOPS_PAT}"
  projects:
    - name: "WebAppProject"
      id: "web-app-project"
    - name: "MobileAppProject"
      id: "mobile-app-project"
```

#### OAuth2è®¤è¯
```python
#!/usr/bin/env python3
"""
Azure DevOpsé›†æˆå·¥å…·
å®ç°ä¸Azure DevOpsçš„æ·±åº¦é›†æˆ
"""

import requests
import json
import logging
from typing import Dict, List, Optional
from datetime import datetime

class AzureDevOpsIntegration:
    def __init__(self, config: Dict):
        self.config = config
        self.base_url = config['base_url'].rstrip('/')
        self.organization = self._extract_organization()
        self.logger = logging.getLogger(__name__)
        self.session = requests.Session()
        self._setup_authentication()
    
    def _extract_organization(self) -> str:
        """æå–ç»„ç»‡åç§°"""
        # ä»URLä¸­æå–ç»„ç»‡åç§°
        # https://dev.azure.com/{organization} -> organization
        import re
        match = re.search(r'https://dev\.azure\.com/([^/]+)', self.base_url)
        if match:
            return match.group(1)
        else:
            raise ValueError("Invalid Azure DevOps URL")
    
    def _setup_authentication(self):
        """è®¾ç½®è®¤è¯ä¿¡æ¯"""
        auth_config = self.config['auth']
        
        if auth_config['type'] == 'pat':
            # PATè®¤è¯
            self.session.auth = ('', auth_config['token'])
        elif auth_config['type'] == 'oauth2':
            # OAuth2è®¤è¯
            self.session.headers.update({
                'Authorization': f"Bearer {auth_config['token']}"
            })
    
    def get_work_item(self, project: str, work_item_id: int) -> Optional[Dict]:
        """è·å–å·¥ä½œé¡¹è¯¦æƒ…"""
        try:
            url = f"{self.base_url}/{project}/_apis/wit/workitems/{work_item_id}"
            params = {
                'api-version': '6.0'
            }
            
            response = self.session.get(url, params=params)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            self.logger.error(f"Failed to get work item {work_item_id} in project {project}: {e}")
            return None
    
    def create_work_item_relation(self, project: str, work_item_id: int, 
                                relation_data: Dict) -> bool:
        """åˆ›å»ºå·¥ä½œé¡¹å…³è”"""
        try:
            url = f"{self.base_url}/{project}/_apis/wit/workitems/{work_item_id}"
            params = {
                'api-version': '6.0'
            }
            
            headers = {
                'Content-Type': 'application/json-patch+json'
            }
            
            # æ„å»ºPATCHè¯·æ±‚ä½“
            patch_data = [
                {
                    'op': 'add',
                    'path': '/relations/-',
                    'value': relation_data
                }
            ]
            
            response = self.session.patch(url, json=patch_data, headers=headers, params=params)
            response.raise_for_status()
            
            self.logger.info(f"Created relation for work item {work_item_id}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to create relation for work item {work_item_id}: {e}")
            return False
    
    def update_work_item(self, project: str, work_item_id: int, 
                        updates: List[Dict]) -> bool:
        """æ›´æ–°å·¥ä½œé¡¹"""
        try:
            url = f"{self.base_url}/{project}/_apis/wit/workitems/{work_item_id}"
            params = {
                'api-version': '6.0'
            }
            
            headers = {
                'Content-Type': 'application/json-patch+json'
            }
            
            response = self.session.patch(url, json=updates, headers=headers, params=params)
            response.raise_for_status()
            
            self.logger.info(f"Updated work item {work_item_id}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to update work item {work_item_id}: {e}")
            return False
```

### 2. å·¥ä½œé¡¹å…³è”å®ç°

å°†ä»£ç æäº¤ä¸Azure DevOpså·¥ä½œé¡¹å…³è”ï¼š

#### æäº¤ä¿¡æ¯è§£æ
```python
#!/usr/bin/env python3
"""
Azure DevOpsæäº¤ä¿¡æ¯è§£æå·¥å…·
è§£æGitæäº¤ä¿¡æ¯ä¸­çš„å·¥ä½œé¡¹å¼•ç”¨
"""

import re
import logging
from typing import List, Dict

class AzureDevOpsCommitParser:
    def __init__(self, project_names: List[str]):
        self.project_names = project_names
        self.logger = logging.getLogger(__name__)
        # æ„å»ºæ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼
        self.work_item_pattern = re.compile(r'#(\d+)')
    
    def extract_work_item_ids(self, commit_message: str) -> List[int]:
        """ä»æäº¤ä¿¡æ¯ä¸­æå–å·¥ä½œé¡¹ID"""
        matches = self.work_item_pattern.findall(commit_message)
        work_item_ids = [int(match) for match in matches]
        return list(set(work_item_ids))  # å»é‡
    
    def parse_commit(self, commit_info: Dict) -> Dict:
        """è§£ææäº¤ä¿¡æ¯"""
        commit_message = commit_info.get('message', '')
        work_item_ids = self.extract_work_item_ids(commit_message)
        
        return {
            'commit_id': commit_info.get('id'),
            'author': commit_info.get('author'),
            'message': commit_message,
            'work_item_ids': work_item_ids,
            'timestamp': commit_info.get('timestamp')
        }

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # é…ç½®é¡¹ç›®åç§°
    project_names = ["WebAppProject", "MobileAppProject"]
    parser = AzureDevOpsCommitParser(project_names)
    
    # æµ‹è¯•æäº¤ä¿¡æ¯
    test_commits = [
        {
            'id': 'abc123',
            'author': 'developer@example.com',
            'message': 'Implement user authentication feature #123',
            'timestamp': '2025-08-30T10:30:00Z'
        },
        {
            'id': 'def456',
            'author': 'tester@example.com',
            'message': 'Fix login timeout issue #456\n\nAlso addresses #789',
            'timestamp': '2025-08-30T11:15:00Z'
        }
    ]
    
    for commit in test_commits:
        parsed = parser.parse_commit(commit)
        print(f"Commit {parsed['commit_id']}:")
        print(f"  Work Items: {parsed['work_item_ids']}")
        print(f"  Message: {parsed['message']}")
```

é€šè¿‡ä¸é¡¹ç›®ç®¡ç†å·¥å…·çš„æ·±åº¦é›†æˆï¼ŒCI/CDå¹³å°èƒ½å¤Ÿå®ç°éœ€æ±‚é©±åŠ¨çš„éƒ¨ç½²ï¼Œç¡®ä¿æ¯ä¸€æ¬¡ä»£ç å˜æ›´éƒ½èƒ½è¿½æº¯åˆ°å…·ä½“çš„ä¸šåŠ¡éœ€æ±‚æˆ–é—®é¢˜ä¿®å¤ã€‚è¿™ä¸ä»…æå‡äº†å›¢é˜Ÿçš„åä½œæ•ˆç‡ï¼Œè¿˜å¢å¼ºäº†è½¯ä»¶äº¤ä»˜è¿‡ç¨‹çš„é€æ˜åº¦å’Œå¯è¿½æº¯æ€§ã€‚å…³é”®æ˜¯è¦æ ¹æ®ç»„ç»‡ä½¿ç”¨çš„å…·ä½“å·¥å…·é€‰æ‹©åˆé€‚çš„é›†æˆæ–¹æ¡ˆï¼Œå¹¶å»ºç«‹å®Œå–„çš„è‡ªåŠ¨åŒ–å…³è”å’ŒçŠ¶æ€åŒæ­¥æœºåˆ¶ã€‚