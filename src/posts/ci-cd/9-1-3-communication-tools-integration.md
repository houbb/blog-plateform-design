---
title: ä¸æ²Ÿé€šå·¥å…·é›†æˆ: æ„å»ºç»“æœé€šçŸ¥ä¸å›¢é˜Ÿåä½œ
date: 2025-08-30
categories: [CICD]
tags: [ci,cd,communication,slack,dingtalk,devops,notification,collaboration]
published: true
---
åœ¨ç°ä»£è½¯ä»¶å¼€å‘å›¢é˜Ÿä¸­ï¼ŒåŠæ—¶æœ‰æ•ˆçš„æ²Ÿé€šæ˜¯ç¡®ä¿é¡¹ç›®æˆåŠŸçš„å…³é”®å› ç´ ã€‚é€šè¿‡å°†CI/CDå¹³å°ä¸å›¢é˜Ÿå¸¸ç”¨çš„æ²Ÿé€šå·¥å…·ï¼ˆå¦‚Slackã€é’‰é’‰ã€Microsoft Teamsç­‰ï¼‰é›†æˆï¼Œå›¢é˜Ÿèƒ½å¤Ÿå®æ—¶è·å¾—æ„å»ºã€æµ‹è¯•ã€éƒ¨ç½²ç­‰å…³é”®ç¯èŠ‚çš„çŠ¶æ€é€šçŸ¥ï¼Œä¿ƒè¿›å›¢é˜Ÿæˆå‘˜ä¹‹é—´çš„åä½œï¼Œå¹¶å¿«é€Ÿå“åº”å’Œè§£å†³é—®é¢˜ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å¦‚ä½•å®ç°CI/CDå¹³å°ä¸ä¸»æµæ²Ÿé€šå·¥å…·çš„æ·±åº¦é›†æˆã€‚

## æ²Ÿé€šå·¥å…·é›†æˆçš„ä»·å€¼

æ²Ÿé€šå·¥å…·é›†æˆä¸ä»…èƒ½å¤Ÿæå‡å›¢é˜Ÿçš„å“åº”é€Ÿåº¦ï¼Œè¿˜èƒ½å¢å¼ºå·¥ä½œæµç¨‹çš„é€æ˜åº¦ã€‚

### 1. å®æ—¶çŠ¶æ€é€šçŸ¥

é€šè¿‡é›†æˆå®ç°å…³é”®äº‹ä»¶çš„å®æ—¶é€šçŸ¥ï¼š
- **æ„å»ºçŠ¶æ€é€šçŸ¥**ï¼šåŠæ—¶å‘ŠçŸ¥å›¢é˜Ÿæˆå‘˜æ„å»ºæˆåŠŸæˆ–å¤±è´¥
- **éƒ¨ç½²çŠ¶æ€é€šçŸ¥**ï¼šé€šçŸ¥éƒ¨ç½²è¿›åº¦å’Œç»“æœ
- **æµ‹è¯•ç»“æœé€šçŸ¥**ï¼šåˆ†äº«è‡ªåŠ¨åŒ–æµ‹è¯•çš„ç»“æœ
- **å®‰å…¨å‘Šè­¦é€šçŸ¥**ï¼šåŠæ—¶é€šæŠ¥å®‰å…¨æ‰«æå‘ç°çš„é—®é¢˜

### 2. ä¸Šä¸‹æ–‡ä¸°å¯Œçš„ä¿¡æ¯

æä¾›åŒ…å«ä¸°å¯Œä¸Šä¸‹æ–‡ä¿¡æ¯çš„é€šçŸ¥ï¼š
- **è¯¦ç»†é“¾æ¥**ï¼šç›´æ¥é“¾æ¥åˆ°ç›¸å…³é¡µé¢ï¼ˆæ„å»ºè¯¦æƒ…ã€éƒ¨ç½²æ—¥å¿—ç­‰ï¼‰
- **ç¯å¢ƒä¿¡æ¯**ï¼šæ˜ç¡®æ ‡è¯†æ“ä½œæ¶‰åŠçš„ç¯å¢ƒ
- **è´£ä»»äººä¿¡æ¯**ï¼šæ˜¾ç¤ºè§¦å‘æ“ä½œçš„äººå‘˜
- **æ—¶é—´æˆ³**ï¼šç²¾ç¡®è®°å½•äº‹ä»¶å‘ç”Ÿæ—¶é—´

### 3. ä¿ƒè¿›å›¢é˜Ÿåä½œ

é€šè¿‡æ²Ÿé€šå·¥å…·ä¿ƒè¿›å›¢é˜Ÿåä½œï¼š
- **å¿«é€Ÿå“åº”**ï¼šå›¢é˜Ÿæˆå‘˜å¯ä»¥å¿«é€Ÿå“åº”é€šçŸ¥ä¸­çš„é—®é¢˜
- **çŸ¥è¯†å…±äº«**ï¼šåˆ†äº«æœ€ä½³å®è·µå’Œè§£å†³æ–¹æ¡ˆ
- **å†³ç­–æ”¯æŒ**ï¼šæä¾›æ•°æ®æ”¯æŒçš„å†³ç­–ä¾æ®
- **æµç¨‹é€æ˜**ï¼šå¢å¼ºå·¥ä½œæµç¨‹çš„å¯è§æ€§

## Slacké›†æˆå®è·µ

Slackä½œä¸ºå¹¿æ³›ä½¿ç”¨çš„å›¢é˜Ÿæ²Ÿé€šå·¥å…·ï¼Œä¸å…¶é›†æˆèƒ½å¤Ÿå®ç°ä¸°å¯Œçš„é€šçŸ¥åŠŸèƒ½ã€‚

### 1. Webhooké…ç½®

Slackæ”¯æŒé€šè¿‡Incoming Webhooksæ¥æ”¶å¤–éƒ¨é€šçŸ¥ï¼š

#### Webhooké…ç½®ç¤ºä¾‹
```yaml
# Slacké›†æˆé…ç½®
slack_integration:
  enabled: true
  webhooks:
    build_notifications:
      url: "${SLACK_BUILD_WEBHOOK_URL}"
      channel: "#ci-cd-notifications"
      username: "CI/CD Bot"
      icon_emoji: ":robot_face:"
    
    deployment_notifications:
      url: "${SLACK_DEPLOYMENT_WEBHOOK_URL}"
      channel: "#deployments"
      username: "Deployment Bot"
      icon_emoji: ":rocket:"
    
    alerts:
      url: "${SLACK_ALERT_WEBHOOK_URL}"
      channel: "#alerts"
      username: "Alert Bot"
      icon_emoji: ":rotating_light:"
  
  message_templates:
    build_success:
      color: "good"
      emoji: ":white_check_mark:"
    
    build_failure:
      color: "danger"
      emoji: ":x:"
    
    deployment_success:
      color: "good"
      emoji: ":rocket:"
    
    deployment_failure:
      color: "danger"
      emoji: ":boom:"
```

#### æ¶ˆæ¯å‘é€å·¥å…·
```python
#!/usr/bin/env python3
"""
Slacké›†æˆå·¥å…·
å®ç°ä¸Slackçš„æ·±åº¦é›†æˆ
"""

import requests
import json
import logging
from typing import Dict, List, Optional
from datetime import datetime

class SlackIntegration:
    def __init__(self, config: Dict):
        self.config = config
        self.webhooks = config.get('webhooks', {})
        self.message_templates = config.get('message_templates', {})
        self.logger = logging.getLogger(__name__)
    
    def send_build_notification(self, build_info: Dict) -> bool:
        """å‘é€æ„å»ºé€šçŸ¥"""
        try:
            webhook_config = self.webhooks.get('build_notifications')
            if not webhook_config:
                self.logger.error("Build notifications webhook not configured")
                return False
            
            # æ„å»ºæ¶ˆæ¯å†…å®¹
            message = self._build_build_message(build_info)
            
            # å‘é€æ¶ˆæ¯
            return self._send_message(webhook_config['url'], message)
        except Exception as e:
            self.logger.error(f"Failed to send build notification: {e}")
            return False
    
    def send_deployment_notification(self, deployment_info: Dict) -> bool:
        """å‘é€éƒ¨ç½²é€šçŸ¥"""
        try:
            webhook_config = self.webhooks.get('deployment_notifications')
            if not webhook_config:
                self.logger.error("Deployment notifications webhook not configured")
                return False
            
            # æ„å»ºæ¶ˆæ¯å†…å®¹
            message = self._build_deployment_message(deployment_info)
            
            # å‘é€æ¶ˆæ¯
            return self._send_message(webhook_config['url'], message)
        except Exception as e:
            self.logger.error(f"Failed to send deployment notification: {e}")
            return False
    
    def send_alert_notification(self, alert_info: Dict) -> bool:
        """å‘é€å‘Šè­¦é€šçŸ¥"""
        try:
            webhook_config = self.webhooks.get('alerts')
            if not webhook_config:
                self.logger.error("Alerts webhook not configured")
                return False
            
            # æ„å»ºæ¶ˆæ¯å†…å®¹
            message = self._build_alert_message(alert_info)
            
            # å‘é€æ¶ˆæ¯
            return self._send_message(webhook_config['url'], message)
        except Exception as e:
            self.logger.error(f"Failed to send alert notification: {e}")
            return False
    
    def _build_build_message(self, build_info: Dict) -> Dict:
        """æ„å»ºæ„å»ºé€šçŸ¥æ¶ˆæ¯"""
        status = build_info.get('status', 'unknown')
        template = self.message_templates.get(f'build_{status}', {})
        
        status_emoji = template.get('emoji', ':question:')
        status_color = template.get('color', '#cccccc')
        
        message = {
            'channel': self.webhooks.get('build_notifications', {}).get('channel', '#general'),
            'username': self.webhooks.get('build_notifications', {}).get('username', 'CI/CD Bot'),
            'icon_emoji': self.webhooks.get('build_notifications', {}).get('icon_emoji', ':robot_face:'),
            'attachments': [
                {
                    'color': status_color,
                    'blocks': [
                        {
                            'type': 'header',
                            'text': {
                                'type': 'plain_text',
                                'text': f'{status_emoji} æ„å»ºé€šçŸ¥ - {build_info.get("project_name", "Unknown")}'
                            }
                        },
                        {
                            'type': 'section',
                            'fields': [
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*æ„å»ºID:*\n{build_info.get("build_id", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*çŠ¶æ€:*\n{status.capitalize()}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*è§¦å‘è€…:*\n{build_info.get("triggered_by", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*åˆ†æ”¯:*\n{build_info.get("branch", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*å¼€å§‹æ—¶é—´:*\n{build_info.get("start_time", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç»“æŸæ—¶é—´:*\n{build_info.get("end_time", "Unknown")}'
                                }
                            ]
                        },
                        {
                            'type': 'actions',
                            'elements': [
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹æ„å»ºè¯¦æƒ…'
                                    },
                                    'url': build_info.get('build_url', '#')
                                }
                            ]
                        }
                    ]
                }
            ]
        }
        
        return message
    
    def _build_deployment_message(self, deployment_info: Dict) -> Dict:
        """æ„å»ºéƒ¨ç½²é€šçŸ¥æ¶ˆæ¯"""
        status = deployment_info.get('status', 'unknown')
        template = self.message_templates.get(f'deployment_{status}', {})
        
        status_emoji = template.get('emoji', ':question:')
        status_color = template.get('color', '#cccccc')
        
        message = {
            'channel': self.webhooks.get('deployment_notifications', {}).get('channel', '#deployments'),
            'username': self.webhooks.get('deployment_notifications', {}).get('username', 'Deployment Bot'),
            'icon_emoji': self.webhooks.get('deployment_notifications', {}).get('icon_emoji', ':rocket:'),
            'attachments': [
                {
                    'color': status_color,
                    'blocks': [
                        {
                            'type': 'header',
                            'text': {
                                'type': 'plain_text',
                                'text': f'{status_emoji} éƒ¨ç½²é€šçŸ¥ - {deployment_info.get("service_name", "Unknown")}'
                            }
                        },
                        {
                            'type': 'section',
                            'fields': [
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç¯å¢ƒ:*\n{deployment_info.get("environment", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç‰ˆæœ¬:*\n{deployment_info.get("version", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*éƒ¨ç½²è€…:*\n{deployment_info.get("deployed_by", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*çŠ¶æ€:*\n{status.capitalize()}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*å¼€å§‹æ—¶é—´:*\n{deployment_info.get("start_time", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç»“æŸæ—¶é—´:*\n{deployment_info.get("end_time", "Unknown")}'
                                }
                            ]
                        },
                        {
                            'type': 'actions',
                            'elements': [
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹éƒ¨ç½²è¯¦æƒ…'
                                    },
                                    'url': deployment_info.get('deployment_url', '#')
                                },
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹æœåŠ¡'
                                    },
                                    'url': deployment_info.get('service_url', '#')
                                }
                            ]
                        }
                    ]
                }
            ]
        }
        
        return message
    
    def _build_alert_message(self, alert_info: Dict) -> Dict:
        """æ„å»ºå‘Šè­¦é€šçŸ¥æ¶ˆæ¯"""
        severity = alert_info.get('severity', 'info')
        severity_emoji = {
            'critical': ':rotating_light:',
            'warning': ':warning:',
            'info': ':information_source:'
        }.get(severity, ':information_source:')
        
        severity_color = {
            'critical': 'danger',
            'warning': 'warning',
            'info': 'good'
        }.get(severity, '#cccccc')
        
        message = {
            'channel': self.webhooks.get('alerts', {}).get('channel', '#alerts'),
            'username': self.webhooks.get('alerts', {}).get('username', 'Alert Bot'),
            'icon_emoji': self.webhooks.get('alerts', {}).get('icon_emoji', ':rotating_light:'),
            'attachments': [
                {
                    'color': severity_color,
                    'blocks': [
                        {
                            'type': 'header',
                            'text': {
                                'type': 'plain_text',
                                'text': f'{severity_emoji} {alert_info.get("alert_name", "Unknown Alert")}'
                            }
                        },
                        {
                            'type': 'section',
                            'text': {
                                'type': 'mrkdwn',
                                'text': alert_info.get('description', 'No description provided')
                            }
                        },
                        {
                            'type': 'section',
                            'fields': [
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ä¸¥é‡çº§åˆ«:*\n{severity.capitalize()}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*è§¦å‘æ—¶é—´:*\n{alert_info.get("timestamp", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*æœåŠ¡:*\n{alert_info.get("service", "Unknown")}'
                                },
                                {
                                    'type': 'mrkdwn',
                                    'text': f'*ç¯å¢ƒ:*\n{alert_info.get("environment", "Unknown")}'
                                }
                            ]
                        },
                        {
                            'type': 'actions',
                            'elements': [
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹å‘Šè­¦è¯¦æƒ…'
                                    },
                                    'url': alert_info.get('alert_url', '#')
                                },
                                {
                                    'type': 'button',
                                    'text': {
                                        'type': 'plain_text',
                                        'text': 'æŸ¥çœ‹ç›‘æ§é¢æ¿'
                                    },
                                    'url': alert_info.get('dashboard_url', '#')
                                }
                            ]
                        }
                    ]
                }
            ]
        }
        
        return message
    
    def _send_message(self, webhook_url: str, message: Dict) -> bool:
        """å‘é€æ¶ˆæ¯åˆ°Slack"""
        try:
            response = requests.post(webhook_url, json=message, timeout=30)
            response.raise_for_status()
            
            self.logger.info("Message sent to Slack successfully")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send message to Slack: {e}")
            return False
```

### 2. äº¤äº’å¼æ¶ˆæ¯

åˆ©ç”¨Slackçš„äº¤äº’åŠŸèƒ½æå‡ç”¨æˆ·ä½“éªŒï¼š

#### æŒ‰é’®äº¤äº’å®ç°
```python
#!/usr/bin/env python3
"""
Slackäº¤äº’å¼æ¶ˆæ¯å¤„ç†å·¥å…·
å¤„ç†SlackæŒ‰é’®ç‚¹å‡»ç­‰äº¤äº’äº‹ä»¶
"""

import json
import hmac
import hashlib
import logging
from typing import Dict, Any
from flask import Flask, request, jsonify

class SlackInteractionHandler:
    def __init__(self, signing_secret: str):
        self.signing_secret = signing_secret
        self.logger = logging.getLogger(__name__)
        self.app = Flask(__name__)
        self._setup_routes()
    
    def _setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        self.app.add_url_rule(
            '/slack/interaction', 
            'slack_interaction', 
            self._handle_interaction, 
            methods=['POST']
        )
    
    def _handle_interaction(self):
        """å¤„ç†äº¤äº’äº‹ä»¶"""
        try:
            # éªŒè¯è¯·æ±‚ç­¾å
            if not self._verify_signature(request):
                return jsonify({'error': 'Invalid signature'}), 401
            
            # è§£æè¯·æ±‚æ•°æ®
            payload = json.loads(request.form.get('payload', '{}'))
            
            # å¤„ç†ä¸åŒç±»å‹çš„äº¤äº’
            if payload.get('type') == 'block_actions':
                return self._handle_block_actions(payload)
            elif payload.get('type') == 'view_submission':
                return self._handle_view_submission(payload)
            else:
                self.logger.warning(f"Unknown interaction type: {payload.get('type')}")
                return jsonify({'status': 'ok'})
        
        except Exception as e:
            self.logger.error(f"Failed to handle Slack interaction: {e}")
            return jsonify({'error': 'Internal server error'}), 500
    
    def _verify_signature(self, req) -> bool:
        """éªŒè¯è¯·æ±‚ç­¾å"""
        timestamp = req.headers.get('X-Slack-Request-Timestamp')
        signature = req.headers.get('X-Slack-Signature')
        body = req.get_data().decode('utf-8')
        
        # æ£€æŸ¥æ—¶é—´æˆ³ï¼ˆé˜²æ­¢é‡æ”¾æ”»å‡»ï¼‰
        import time
        if abs(time.time() - int(timestamp)) > 60 * 5:  # 5åˆ†é’Ÿå†…æœ‰æ•ˆ
            return False
        
        # æ„å»ºç­¾åå­—ç¬¦ä¸²
        sig_basestring = f"v0:{timestamp}:{body}"
        my_signature = 'v0=' + hmac.new(
            self.signing_secret.encode(),
            sig_basestring.encode(),
            hashlib.sha256
        ).hexdigest()
        
        return hmac.compare_digest(my_signature, signature)
    
    def _handle_block_actions(self, payload: Dict) -> Any:
        """å¤„ç†å—æ“ä½œ"""
        actions = payload.get('actions', [])
        for action in actions:
            action_id = action.get('action_id')
            block_id = action.get('block_id')
            
            if action_id == 'view_build_details':
                return self._handle_view_build_details(action, payload)
            elif action_id == 'retry_build':
                return self._handle_retry_build(action, payload)
            elif action_id == 'rollback_deployment':
                return self._handle_rollback_deployment(action, payload)
            else:
                self.logger.warning(f"Unknown action ID: {action_id}")
        
        return jsonify({'status': 'ok'})
    
    def _handle_view_build_details(self, action: Dict, payload: Dict) -> Any:
        """å¤„ç†æŸ¥çœ‹æ„å»ºè¯¦æƒ…æ“ä½œ"""
        build_id = action.get('value')
        user_id = payload.get('user', {}).get('id')
        
        self.logger.info(f"User {user_id} requested build details for {build_id}")
        
        # è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„æ„å»ºè¯¦æƒ…å±•ç¤ºé€»è¾‘
        # ä¾‹å¦‚ï¼šæ‰“å¼€ä¸€ä¸ªæ¨¡æ€å¯¹è¯æ¡†æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
        
        return jsonify({
            'response_action': 'open_view',
            'view': {
                'type': 'modal',
                'title': {
                    'type': 'plain_text',
                    'text': 'æ„å»ºè¯¦æƒ…'
                },
                'blocks': [
                    {
                        'type': 'section',
                        'text': {
                            'type': 'mrkdwn',
                            'text': f'æ­£åœ¨åŠ è½½æ„å»º {build_id} çš„è¯¦ç»†ä¿¡æ¯...'
                        }
                    }
                ]
            }
        })
    
    def _handle_retry_build(self, action: Dict, payload: Dict) -> Any:
        """å¤„ç†é‡è¯•æ„å»ºæ“ä½œ"""
        build_id = action.get('value')
        user_id = payload.get('user', {}).get('id')
        
        self.logger.info(f"User {user_id} requested to retry build {build_id}")
        
        # è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„é‡è¯•æ„å»ºé€»è¾‘
        # ä¾‹å¦‚ï¼šè°ƒç”¨CI/CDå¹³å°APIé‡æ–°è§¦å‘æ„å»º
        
        return jsonify({
            'response_action': 'update',
            'blocks': [
                {
                    'type': 'section',
                    'text': {
                        'type': 'mrkdwn',
                        'text': f':hourglass_flowing_sand: æ­£åœ¨é‡è¯•æ„å»º {build_id}...'
                    }
                }
            ]
        })
    
    def _handle_rollback_deployment(self, action: Dict, payload: Dict) -> Any:
        """å¤„ç†å›æ»šéƒ¨ç½²æ“ä½œ"""
        deployment_id = action.get('value')
        user_id = payload.get('user', {}).get('id')
        
        self.logger.info(f"User {user_id} requested to rollback deployment {deployment_id}")
        
        # è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„å›æ»šéƒ¨ç½²é€»è¾‘
        # ä¾‹å¦‚ï¼šè°ƒç”¨éƒ¨ç½²å¹³å°APIè§¦å‘å›æ»š
        
        return jsonify({
            'response_action': 'update',
            'blocks': [
                {
                    'type': 'section',
                    'text': {
                        'type': 'mrkdwn',
                        'text': f':hourglass_flowing_sand: æ­£åœ¨å›æ»šéƒ¨ç½² {deployment_id}...'
                    }
                }
            ]
        })
    
    def run(self, host: str = '0.0.0.0', port: int = 5000):
        """è¿è¡ŒæœåŠ¡"""
        self.app.run(host=host, port=port, debug=False)
```

## é’‰é’‰é›†æˆå®è·µ

é’ˆå¯¹å›½å†…ç”¨æˆ·ï¼Œé’‰é’‰ä½œä¸ºå¹¿æ³›ä½¿ç”¨çš„æ²Ÿé€šå·¥å…·ï¼Œä¸å…¶é›†æˆåŒæ ·é‡è¦ã€‚

### 1. æœºå™¨äººé…ç½®

é’‰é’‰æ”¯æŒé€šè¿‡è‡ªå®šä¹‰æœºå™¨äººæ¥æ”¶å¤–éƒ¨é€šçŸ¥ï¼š

#### æœºå™¨äººé…ç½®ç¤ºä¾‹
```yaml
# é’‰é’‰é›†æˆé…ç½®
dingtalk_integration:
  enabled: true
  robots:
    build_notifications:
      webhook_url: "${DINGTALK_BUILD_WEBHOOK_URL}"
      secret: "${DINGTALK_BUILD_SECRET}"
    
    deployment_notifications:
      webhook_url: "${DINGTALK_DEPLOYMENT_WEBHOOK_URL}"
      secret: "${DINGTALK_DEPLOYMENT_SECRET}"
    
    alerts:
      webhook_url: "${DINGTALK_ALERT_WEBHOOK_URL}"
      secret: "${DINGTALK_ALERT_SECRET}"
```

#### æ¶ˆæ¯å‘é€å·¥å…·
```python
#!/usr/bin/env python3
"""
é’‰é’‰é›†æˆå·¥å…·
å®ç°ä¸é’‰é’‰çš„æ·±åº¦é›†æˆ
"""

import requests
import json
import hmac
import hashlib
import base64
import urllib.parse
import time
import logging
from typing import Dict, Any

class DingtalkIntegration:
    def __init__(self, config: Dict):
        self.config = config
        self.robots = config.get('robots', {})
        self.logger = logging.getLogger(__name__)
    
    def _generate_sign(self, secret: str) -> tuple:
        """ç”Ÿæˆç­¾å"""
        if not secret:
            return "", ""
        
        timestamp = str(round(time.time() * 1000))
        secret_enc = secret.encode('utf-8')
        string_to_sign = '{}\n{}'.format(timestamp, secret)
        string_to_sign_enc = string_to_sign.encode('utf-8')
        hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()
        sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
        return timestamp, sign
    
    def send_message(self, robot_name: str, message: Dict[str, Any]) -> bool:
        """å‘é€æ¶ˆæ¯"""
        try:
            robot_config = self.robots.get(robot_name)
            if not robot_config:
                self.logger.error(f"Robot {robot_name} not configured")
                return False
            
            # æ„å»ºè¯·æ±‚URL
            webhook_url = robot_config['webhook_url']
            secret = robot_config.get('secret')
            
            if secret:
                timestamp, sign = self._generate_sign(secret)
                webhook_url = f"{webhook_url}&timestamp={timestamp}&sign={sign}"
            
            # å‘é€è¯·æ±‚
            response = requests.post(webhook_url, json=message, timeout=30)
            response.raise_for_status()
            
            result = response.json()
            if result.get('errcode') != 0:
                self.logger.error(f"Failed to send Dingtalk message: {result}")
                return False
            
            self.logger.info(f"Message sent to Dingtalk robot {robot_name} successfully")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send Dingtalk message: {e}")
            return False
    
    def send_build_notification(self, build_info: Dict) -> bool:
        """å‘é€æ„å»ºé€šçŸ¥"""
        status = build_info.get('status', 'unknown')
        status_emoji = {
            'success': 'âœ…',
            'failed': 'âŒ',
            'running': 'â³',
            'cancelled': 'ğŸš«'
        }.get(status, 'â“')
        
        message = {
            "msgtype": "markdown",
            "markdown": {
                "title": f"æ„å»ºé€šçŸ¥ - {build_info.get('project_name', 'Unknown')}",
                "text": f"""## {status_emoji} æ„å»ºé€šçŸ¥\n\n**é¡¹ç›®åç§°**: {build_info.get('project_name', 'Unknown')}\n\n**æ„å»ºID**: {build_info.get('build_id', 'Unknown')}\n\n**çŠ¶æ€**: {status.capitalize()}\n\n**è§¦å‘è€…**: {build_info.get('triggered_by', 'Unknown')}\n\n**åˆ†æ”¯**: {build_info.get('branch', 'Unknown')}\n\n**å¼€å§‹æ—¶é—´**: {build_info.get('start_time', 'Unknown')}\n\n**ç»“æŸæ—¶é—´**: {build_info.get('end_time', 'Unknown')}\n\n[æŸ¥çœ‹æ„å»ºè¯¦æƒ…]({build_info.get('build_url', '#')})"""
            }
        }
        
        return self.send_message('build_notifications', message)
    
    def send_deployment_notification(self, deployment_info: Dict) -> bool:
        """å‘é€éƒ¨ç½²é€šçŸ¥"""
        status = deployment_info.get('status', 'unknown')
        status_emoji = {
            'success': 'ğŸš€',
            'failed': 'ğŸ’¥',
            'running': 'â³',
            'cancelled': 'ğŸš«'
        }.get(status, 'â“')
        
        message = {
            "msgtype": "markdown",
            "markdown": {
                "title": f"éƒ¨ç½²é€šçŸ¥ - {deployment_info.get('service_name', 'Unknown')}",
                "text": f"""## {status_emoji} éƒ¨ç½²é€šçŸ¥\n\n**æœåŠ¡åç§°**: {deployment_info.get('service_name', 'Unknown')}\n\n**ç¯å¢ƒ**: {deployment_info.get('environment', 'Unknown')}\n\n**ç‰ˆæœ¬**: {deployment_info.get('version', 'Unknown')}\n\n**éƒ¨ç½²è€…**: {deployment_info.get('deployed_by', 'Unknown')}\n\n**çŠ¶æ€**: {status.capitalize()}\n\n**å¼€å§‹æ—¶é—´**: {deployment_info.get('start_time', 'Unknown')}\n\n**ç»“æŸæ—¶é—´**: {deployment_info.get('end_time', 'Unknown')}\n\n[æŸ¥çœ‹éƒ¨ç½²è¯¦æƒ…]({deployment_info.get('deployment_url', '#')}) | [æŸ¥çœ‹æœåŠ¡]({deployment_info.get('service_url', '#')})"""
            }
        }
        
        return self.send_message('deployment_notifications', message)
    
    def send_alert_notification(self, alert_info: Dict) -> bool:
        """å‘é€å‘Šè­¦é€šçŸ¥"""
        severity = alert_info.get('severity', 'info')
        severity_emoji = {
            'critical': 'ğŸš¨',
            'warning': 'âš ï¸',
            'info': 'â„¹ï¸'
        }.get(severity, 'â„¹ï¸')
        
        message = {
            "msgtype": "markdown",
            "markdown": {
                "title": f"{severity_emoji} {alert_info.get('alert_name', 'Unknown Alert')}",
                "text": f"""## {severity_emoji} {alert_info.get('alert_name', 'Unknown Alert')}\n\n{alert_info.get('description', 'No description provided')}\n\n**ä¸¥é‡çº§åˆ«**: {severity.capitalize()}\n\n**è§¦å‘æ—¶é—´**: {alert_info.get('timestamp', 'Unknown')}\n\n**æœåŠ¡**: {alert_info.get('service', 'Unknown')}\n\n**ç¯å¢ƒ**: {alert_info.get('environment', 'Unknown')}\n\n[æŸ¥çœ‹å‘Šè­¦è¯¦æƒ…]({alert_info.get('alert_url', '#')}) | [æŸ¥çœ‹ç›‘æ§é¢æ¿]({alert_info.get('dashboard_url', '#')})"""
            }
        }
        
        return self.send_message('alerts', message)
```

### 2. ä¼ä¸šå†…éƒ¨åº”ç”¨é›†æˆ

å¯¹äºæ›´å¤æ‚çš„é›†æˆéœ€æ±‚ï¼Œå¯ä»¥å¼€å‘é’‰é’‰ä¼ä¸šå†…éƒ¨åº”ç”¨ï¼š

#### åº”ç”¨é…ç½®
```python
#!/usr/bin/env python3
"""
é’‰é’‰ä¼ä¸šåº”ç”¨é›†æˆå·¥å…·
å®ç°ä¸é’‰é’‰ä¼ä¸šå†…éƒ¨åº”ç”¨çš„æ·±åº¦é›†æˆ
"""

import requests
import json
import logging
from typing import Dict, List, Optional
from datetime import datetime

class DingtalkAppIntegration:
    def __init__(self, app_key: str, app_secret: str):
        self.app_key = app_key
        self.app_secret = app_secret
        self.access_token = None
        self.token_expires_at = 0
        self.logger = logging.getLogger(__name__)
    
    def _get_access_token(self) -> str:
        """è·å–è®¿é—®ä»¤ç‰Œ"""
        # æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœŸ
        if self.access_token and datetime.now().timestamp() < self.token_expires_at:
            return self.access_token
        
        try:
            url = "https://oapi.dingtalk.com/gettoken"
            params = {
                'appkey': self.app_key,
                'appsecret': self.app_secret
            }
            
            response = requests.get(url, params=params, timeout=30)
            response.raise_for_status()
            
            result = response.json()
            if result.get('errcode') != 0:
                raise Exception(f"Failed to get access token: {result}")
            
            self.access_token = result['access_token']
            # ä»¤ç‰Œæœ‰æ•ˆæœŸé€šå¸¸ä¸º2å°æ—¶ï¼Œæå‰10åˆ†é’Ÿåˆ·æ–°
            self.token_expires_at = datetime.now().timestamp() + result['expires_in'] - 600
            
            return self.access_token
        except Exception as e:
            self.logger.error(f"Failed to get access token: {e}")
            raise
    
    def send_work_message(self, user_ids: List[str], message: Dict) -> bool:
        """å‘é€å·¥ä½œé€šçŸ¥æ¶ˆæ¯"""
        try:
            access_token = self._get_access_token()
            
            url = "https://oapi.dingtalk.com/topapi/message/corpconversation/asyncsend_v2"
            params = {
                'access_token': access_token
            }
            
            data = {
                'userid_list': ','.join(user_ids),
                'agent_id': self._get_agent_id(),
                'msg': message
            }
            
            response = requests.post(url, params=params, json=data, timeout=30)
            response.raise_for_status()
            
            result = response.json()
            if result.get('errcode') != 0:
                self.logger.error(f"Failed to send work message: {result}")
                return False
            
            self.logger.info("Work message sent successfully")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send work message: {e}")
            return False
    
    def _get_agent_id(self) -> str:
        """è·å–åº”ç”¨ä»£ç†ID"""
        # è¿™é‡Œåº”è¯¥ä»é…ç½®æˆ–é€šè¿‡APIè·å–
        return "123456789"  # ç¤ºä¾‹ID
    
    def create_chat_group(self, name: str, owner: str, user_ids: List[str]) -> Optional[str]:
        """åˆ›å»ºç¾¤èŠ"""
        try:
            access_token = self._get_access_token()
            
            url = "https://oapi.dingtalk.com/chat/create"
            params = {
                'access_token': access_token
            }
            
            data = {
                'name': name,
                'owner': owner,
                'useridlist': user_ids
            }
            
            response = requests.post(url, params=params, json=data, timeout=30)
            response.raise_for_status()
            
            result = response.json()
            if result.get('errcode') != 0:
                self.logger.error(f"Failed to create chat group: {result}")
                return None
            
            return result.get('chatid')
        except Exception as e:
            self.logger.error(f"Failed to create chat group: {e}")
            return None
    
    def send_chat_message(self, chat_id: str, message: Dict) -> bool:
        """å‘é€ç¾¤èŠæ¶ˆæ¯"""
        try:
            access_token = self._get_access_token()
            
            url = "https://oapi.dingtalk.com/chat/send"
            params = {
                'access_token': access_token
            }
            
            data = {
                'chatid': chat_id,
                'msg': message
            }
            
            response = requests.post(url, params=params, json=data, timeout=30)
            response.raise_for_status()
            
            result = response.json()
            if result.get('errcode') != 0:
                self.logger.error(f"Failed to send chat message: {result}")
                return False
            
            self.logger.info("Chat message sent successfully")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send chat message: {e}")
            return False
```

## Microsoft Teamsé›†æˆå®è·µ

Microsoft Teamsä½œä¸ºä¼ä¸šçº§æ²Ÿé€šå¹³å°ï¼Œä¹Ÿæ”¯æŒä¸°å¯Œçš„é›†æˆèƒ½åŠ›ã€‚

### 1. Incoming Webhooké…ç½®

Teamsæ”¯æŒé€šè¿‡Incoming Webhooksæ¥æ”¶å¤–éƒ¨é€šçŸ¥ï¼š

#### Webhooké…ç½®ç¤ºä¾‹
```yaml
# Microsoft Teamsé›†æˆé…ç½®
teams_integration:
  enabled: true
  webhooks:
    build_notifications:
      url: "${TEAMS_BUILD_WEBHOOK_URL}"
    
    deployment_notifications:
      url: "${TEAMS_DEPLOYMENT_WEBHOOK_URL}"
    
    alerts:
      url: "${TEAMS_ALERT_WEBHOOK_URL}"
```

#### æ¶ˆæ¯å‘é€å·¥å…·
```python
#!/usr/bin/env python3
"""
Microsoft Teamsé›†æˆå·¥å…·
å®ç°ä¸Microsoft Teamsçš„æ·±åº¦é›†æˆ
"""

import requests
import json
import logging
from typing import Dict, Any

class TeamsIntegration:
    def __init__(self, config: Dict):
        self.config = config
        self.webhooks = config.get('webhooks', {})
        self.logger = logging.getLogger(__name__)
    
    def send_message(self, webhook_name: str, message: Dict[str, Any]) -> bool:
        """å‘é€æ¶ˆæ¯åˆ°Teams"""
        try:
            webhook_url = self.webhooks.get(webhook_name)
            if not webhook_url:
                self.logger.error(f"Webhook {webhook_name} not configured")
                return False
            
            response = requests.post(webhook_url, json=message, timeout=30)
            response.raise_for_status()
            
            self.logger.info(f"Message sent to Teams webhook {webhook_name} successfully")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send message to Teams: {e}")
            return False
    
    def send_build_notification(self, build_info: Dict) -> bool:
        """å‘é€æ„å»ºé€šçŸ¥"""
        status = build_info.get('status', 'unknown')
        status_emoji = {
            'success': 'âœ…',
            'failed': 'âŒ',
            'running': 'â³',
            'cancelled': 'ğŸš«'
        }.get(status, 'â“')
        
        message = {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "themeColor": "0076D7",
            "summary": f"Build {status} - {build_info.get('project_name', 'Unknown')}",
            "sections": [
                {
                    "activityTitle": f"{status_emoji} æ„å»ºé€šçŸ¥",
                    "activitySubtitle": f"é¡¹ç›®: {build_info.get('project_name', 'Unknown')}",
                    "facts": [
                        {
                            "name": "æ„å»ºID",
                            "value": build_info.get('build_id', 'Unknown')
                        },
                        {
                            "name": "çŠ¶æ€",
                            "value": status.capitalize()
                        },
                        {
                            "name": "è§¦å‘è€…",
                            "value": build_info.get('triggered_by', 'Unknown')
                        },
                        {
                            "name": "åˆ†æ”¯",
                            "value": build_info.get('branch', 'Unknown')
                        },
                        {
                            "name": "å¼€å§‹æ—¶é—´",
                            "value": build_info.get('start_time', 'Unknown')
                        },
                        {
                            "name": "ç»“æŸæ—¶é—´",
                            "value": build_info.get('end_time', 'Unknown')
                        }
                    ],
                    "markdown": True
                }
            ],
            "potentialAction": [
                {
                    "@type": "OpenUri",
                    "name": "æŸ¥çœ‹æ„å»ºè¯¦æƒ…",
                    "targets": [
                        {
                            "os": "default",
                            "uri": build_info.get('build_url', '#')
                        }
                    ]
                }
            ]
        }
        
        return self.send_message('build_notifications', message)
    
    def send_deployment_notification(self, deployment_info: Dict) -> bool:
        """å‘é€éƒ¨ç½²é€šçŸ¥"""
        status = deployment_info.get('status', 'unknown')
        status_color = {
            'success': '28a745',
            'failed': 'dc3545',
            'running': 'ffc107',
            'cancelled': '6c757d'
        }.get(status, '0076D7')
        
        status_emoji = {
            'success': 'ğŸš€',
            'failed': 'ğŸ’¥',
            'running': 'â³',
            'cancelled': 'ğŸš«'
        }.get(status, 'â“')
        
        message = {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "themeColor": status_color,
            "summary": f"Deployment {status} - {deployment_info.get('service_name', 'Unknown')}",
            "sections": [
                {
                    "activityTitle": f"{status_emoji} éƒ¨ç½²é€šçŸ¥",
                    "activitySubtitle": f"æœåŠ¡: {deployment_info.get('service_name', 'Unknown')}",
                    "facts": [
                        {
                            "name": "ç¯å¢ƒ",
                            "value": deployment_info.get('environment', 'Unknown')
                        },
                        {
                            "name": "ç‰ˆæœ¬",
                            "value": deployment_info.get('version', 'Unknown')
                        },
                        {
                            "name": "éƒ¨ç½²è€…",
                            "value": deployment_info.get('deployed_by', 'Unknown')
                        },
                        {
                            "name": "çŠ¶æ€",
                            "value": status.capitalize()
                        },
                        {
                            "name": "å¼€å§‹æ—¶é—´",
                            "value": deployment_info.get('start_time', 'Unknown')
                        },
                        {
                            "name": "ç»“æŸæ—¶é—´",
                            "value": deployment_info.get('end_time', 'Unknown')
                        }
                    ],
                    "markdown": True
                }
            ],
            "potentialAction": [
                {
                    "@type": "OpenUri",
                    "name": "æŸ¥çœ‹éƒ¨ç½²è¯¦æƒ…",
                    "targets": [
                        {
                            "os": "default",
                            "uri": deployment_info.get('deployment_url', '#')
                        }
                    ]
                },
                {
                    "@type": "OpenUri",
                    "name": "æŸ¥çœ‹æœåŠ¡",
                    "targets": [
                        {
                            "os": "default",
                            "uri": deployment_info.get('service_url', '#')
                        }
                    ]
                }
            ]
        }
        
        return self.send_message('deployment_notifications', message)
```

é€šè¿‡ä¸æ²Ÿé€šå·¥å…·çš„æ·±åº¦é›†æˆï¼ŒCI/CDå¹³å°èƒ½å¤Ÿå®ç°åŠæ—¶çš„çŠ¶æ€é€šçŸ¥å’Œå›¢é˜Ÿåä½œï¼Œæå‡å›¢é˜Ÿçš„å“åº”é€Ÿåº¦å’Œå·¥ä½œæ•ˆç‡ã€‚å…³é”®æ˜¯è¦æ ¹æ®å›¢é˜Ÿä½¿ç”¨çš„å…·ä½“æ²Ÿé€šå·¥å…·é€‰æ‹©åˆé€‚çš„é›†æˆæ–¹æ¡ˆï¼Œå¹¶è®¾è®¡ä¸°å¯Œçš„æ¶ˆæ¯æ ¼å¼å’Œäº¤äº’åŠŸèƒ½ï¼Œä»¥æä¾›æœ€ä½³çš„ç”¨æˆ·ä½“éªŒã€‚