---
title: "è‡ªç„¶è¯­è¨€æŸ¥è¯¢ä¸è¯­éŸ³äº¤äº’: é™ä½ä½¿ç”¨é—¨æ§›"
date: 2025-08-30
categories: [Measure]
tags: [Measure]
published: true
---
åœ¨ä¼ä¸šçº§ç»Ÿä¸€åº¦é‡å¹³å°çš„å‘å±•è¿‡ç¨‹ä¸­ï¼Œé™ä½æ•°æ®ä½¿ç”¨é—¨æ§›ä¸€ç›´æ˜¯é‡è¦çš„ç›®æ ‡ã€‚ä¼ ç»Ÿçš„æ•°æ®åˆ†æéœ€è¦ç”¨æˆ·å…·å¤‡ä¸€å®šçš„æŠ€æœ¯èƒŒæ™¯ï¼Œèƒ½å¤Ÿç¼–å†™SQLæŸ¥è¯¢æˆ–ä½¿ç”¨å¤æ‚çš„å¯è§†åŒ–å·¥å…·ã€‚ç„¶è€Œï¼Œéšç€äººå·¥æ™ºèƒ½æŠ€æœ¯çš„å¿«é€Ÿå‘å±•ï¼Œè‡ªç„¶è¯­è¨€æŸ¥è¯¢ï¼ˆNatural Language Query, NLQï¼‰å’Œè¯­éŸ³äº¤äº’æŠ€æœ¯ä¸ºæ™®é€šç”¨æˆ·æä¾›äº†æ›´åŠ ç›´è§‚ã€ä¾¿æ·çš„æ•°æ®è®¿é—®æ–¹å¼ã€‚æœ¬èŠ‚å°†æ·±å…¥æ¢è®¨å¦‚ä½•è®¾è®¡å’Œå®ç°è‡ªç„¶è¯­è¨€æŸ¥è¯¢ä¸è¯­éŸ³äº¤äº’åŠŸèƒ½ï¼Œè®©æ•°æ®åˆ†æå˜å¾—æ›´åŠ æ™®åŠåŒ–å’Œäººæ€§åŒ–ã€‚

## è‡ªç„¶è¯­è¨€æŸ¥è¯¢çš„æ ¸å¿ƒä»·å€¼

### 1.1 é™ä½æŠ€æœ¯é—¨æ§›

è‡ªç„¶è¯­è¨€æŸ¥è¯¢æŠ€æœ¯ä½¿å¾—éæŠ€æœ¯ç”¨æˆ·ä¹Ÿèƒ½è½»æ¾è¿›è¡Œæ•°æ®åˆ†æï¼š

```yaml
é™ä½æŠ€æœ¯é—¨æ§›çš„ä»·å€¼:
  æ˜“ç”¨æ€§æå‡:
    - æ— éœ€å­¦ä¹ SQLæˆ–æŸ¥è¯¢è¯­æ³•
    - æ”¯æŒæ—¥å¸¸è¯­è¨€è¡¨è¾¾æŸ¥è¯¢æ„å›¾
    - æä¾›æ™ºèƒ½æç¤ºå’Œçº é”™åŠŸèƒ½
  æ™®åŠåŒ–åº”ç”¨:
    - è®©ä¸šåŠ¡äººå‘˜ä¹Ÿèƒ½è¿›è¡Œæ•°æ®åˆ†æ
    - å‡å°‘å¯¹æ•°æ®åˆ†æå¸ˆçš„ä¾èµ–
    - æé«˜æ•°æ®é©±åŠ¨å†³ç­–çš„æ•ˆç‡
  äº¤äº’ä½“éªŒ:
    - æä¾›æ›´è‡ªç„¶çš„æŸ¥è¯¢æ–¹å¼
    - æ”¯æŒè¿­ä»£å¼æŸ¥è¯¢ä¼˜åŒ–
    - å®ç°æ™ºèƒ½é—®ç­”äº¤äº’
```

### 1.2 æå‡åˆ†ææ•ˆç‡

é€šè¿‡è‡ªç„¶è¯­è¨€äº¤äº’ï¼Œç”¨æˆ·å¯ä»¥æ›´å¿«é€Ÿåœ°è·å–æ‰€éœ€ä¿¡æ¯ï¼š

```yaml
æå‡åˆ†ææ•ˆç‡:
  å¿«é€ŸæŸ¥è¯¢:
    - ç›´æ¥ç”¨è¯­è¨€æè¿°æŸ¥è¯¢éœ€æ±‚
    - æ— éœ€æ„å»ºå¤æ‚çš„æŸ¥è¯¢æ¡ä»¶
    - æ”¯æŒæ¨¡ç³ŠæŸ¥è¯¢å’Œè¿‘ä¼¼åŒ¹é…
  æ™ºèƒ½æ¨è:
    - åŸºäºå†å²æŸ¥è¯¢æ¨èç›¸å…³é—®é¢˜
    - æä¾›æŸ¥è¯¢ç»“æœçš„æ·±åº¦åˆ†æ
    - è‡ªåŠ¨ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨
  ä¸Šä¸‹æ–‡ç†è§£:
    - ç†è§£æŸ¥è¯¢çš„ä¸Šä¸‹æ–‡å…³ç³»
    - æ”¯æŒå¤šè½®å¯¹è¯å¼äº¤äº’
    - è®°å½•ç”¨æˆ·åå¥½å’Œä¹ æƒ¯
```

## è‡ªç„¶è¯­è¨€æŸ¥è¯¢æŠ€æœ¯æ¶æ„

### 2.1 æ•´ä½“æ¶æ„è®¾è®¡

è‡ªç„¶è¯­è¨€æŸ¥è¯¢ç³»ç»Ÿéœ€è¦æ•´åˆå¤šç§AIæŠ€æœ¯ï¼Œå½¢æˆå®Œæ•´çš„å¤„ç†é“¾è·¯ï¼š

```mermaid
graph TD
    A[ç”¨æˆ·è¾“å…¥] --> B[è¯­éŸ³è¯†åˆ«]
    B --> C[è‡ªç„¶è¯­è¨€ç†è§£]
    C --> D[æ„å›¾è¯†åˆ«]
    C --> E[å®ä½“æå–]
    D --> F[æŸ¥è¯¢è§„åˆ’]
    E --> F
    F --> G[æŸ¥è¯¢æ‰§è¡Œ]
    G --> H[ç»“æœç”Ÿæˆ]
    H --> I[è‡ªç„¶è¯­è¨€ç”Ÿæˆ]
    I --> J[ç»“æœå±•ç¤º]
    
    K[çŸ¥è¯†å›¾è°±] --> C
    K --> F
    L[å…ƒæ•°æ®ç®¡ç†] --> F
    M[å†å²æŸ¥è¯¢] --> D
```

### 2.2 æ ¸å¿ƒç»„ä»¶å®ç°

#### 2.2.1 è‡ªç„¶è¯­è¨€ç†è§£ï¼ˆNLUï¼‰

```python
class NaturalLanguageUnderstanding:
    def __init__(self, model_path, knowledge_base):
        self.nlp_model = self.load_model(model_path)
        self.knowledge_base = knowledge_base
        self.intent_classifier = IntentClassifier()
        self.entity_extractor = EntityExtractor()
        self.query_parser = QueryParser()
    
    def understand_query(self, user_input):
        """
        ç†è§£ç”¨æˆ·è‡ªç„¶è¯­è¨€æŸ¥è¯¢
        """
        # æ–‡æœ¬é¢„å¤„ç†
        processed_text = self.preprocess_text(user_input)
        
        # æ„å›¾è¯†åˆ«
        intent = self.intent_classifier.classify(processed_text)
        
        # å®ä½“æå–
        entities = self.entity_extractor.extract(processed_text)
        
        # æŸ¥è¯¢è§£æ
        parsed_query = self.query_parser.parse(processed_text, intent, entities)
        
        # ä¸Šä¸‹æ–‡ç†è§£
        context = self.understand_context(parsed_query)
        
        return {
            'original_input': user_input,
            'processed_text': processed_text,
            'intent': intent,
            'entities': entities,
            'parsed_query': parsed_query,
            'context': context
        }
    
    def preprocess_text(self, text):
        """
        æ–‡æœ¬é¢„å¤„ç†
        """
        # è½¬æ¢ä¸ºå°å†™
        text = text.lower()
        
        # ç§»é™¤ç‰¹æ®Šå­—ç¬¦
        text = re.sub(r'[^\w\s]', '', text)
        
        # æ ‡å‡†åŒ–åŒä¹‰è¯
        text = self.standardize_synonyms(text)
        
        # çº æ­£æ‹¼å†™é”™è¯¯
        text = self.correct_spelling(text)
        
        return text
    
    def standardize_synonyms(self, text):
        """
        æ ‡å‡†åŒ–åŒä¹‰è¯
        """
        synonyms = {
            'revenue': ['æ”¶å…¥', 'è¥æ”¶', 'é”€å”®é¢'],
            'user': ['ç”¨æˆ·', 'å®¢æˆ·', 'æ¶ˆè´¹è€…'],
            'product': ['äº§å“', 'å•†å“', 'è´§å“'],
            'region': ['åœ°åŒº', 'åŒºåŸŸ', 'åœ°åŸŸ'],
            'time': ['æ—¶é—´', 'æ—¥æœŸ', 'æ—¶æœŸ']
        }
        
        for standard_term, variations in synonyms.items():
            for variation in variations:
                text = text.replace(variation, standard_term)
        
        return text
    
    def correct_spelling(self, text):
        """
        çº æ­£æ‹¼å†™é”™è¯¯
        """
        # ä½¿ç”¨æ‹¼å†™æ£€æŸ¥åº“è¿›è¡Œçº é”™
        # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…å®ç°ä¼šæ›´å¤æ‚
        return text
    
    def understand_context(self, parsed_query):
        """
        ç†è§£æŸ¥è¯¢ä¸Šä¸‹æ–‡
        """
        context = {}
        
        # ä»çŸ¥è¯†åº“è·å–ç›¸å…³ä¸Šä¸‹æ–‡
        if parsed_query.get('entities'):
            for entity in parsed_query['entities']:
                related_info = self.knowledge_base.get_related_info(entity)
                context.update(related_info)
        
        return context
```

#### 2.2.2 æŸ¥è¯¢è§„åˆ’ä¸æ‰§è¡Œ

```java
@Service
public class QueryPlanner {
    
    @Autowired
    private MetadataService metadataService;
    
    @Autowired
    private QueryExecutor queryExecutor;
    
    @Autowired
    private KnowledgeGraphService knowledgeGraphService;
    
    /**
     * è§„åˆ’è‡ªç„¶è¯­è¨€æŸ¥è¯¢
     */
    public PlannedQuery planQuery(NLUResult nluResult) {
        PlannedQuery plannedQuery = new PlannedQuery();
        
        // è·å–æ„å›¾ä¿¡æ¯
        String intent = nluResult.getIntent();
        
        // è·å–å®ä½“ä¿¡æ¯
        List<Entity> entities = nluResult.getEntities();
        
        // è·å–ä¸Šä¸‹æ–‡ä¿¡æ¯
        Map<String, Object> context = nluResult.getContext();
        
        // æ ¹æ®æ„å›¾ç¡®å®šæŸ¥è¯¢ç±»å‹
        QueryType queryType = determineQueryType(intent);
        plannedQuery.setQueryType(queryType);
        
        // æ„å»ºæŸ¥è¯¢æ¡ä»¶
        QueryConditions conditions = buildQueryConditions(entities, context);
        plannedQuery.setConditions(conditions);
        
        // ç¡®å®šæŸ¥è¯¢ç»´åº¦å’ŒæŒ‡æ ‡
        QuerySchema schema = determineQuerySchema(intent, entities);
        plannedQuery.setSchema(schema);
        
        // ä¼˜åŒ–æŸ¥è¯¢è®¡åˆ’
        optimizeQueryPlan(plannedQuery);
        
        return plannedQuery;
    }
    
    private QueryType determineQueryType(String intent) {
        switch (intent) {
            case "trend_analysis":
                return QueryType.TREND;
            case "comparison_analysis":
                return QueryType.COMPARISON;
            case "ranking_analysis":
                return QueryType.RANKING;
            case "distribution_analysis":
                return QueryType.DISTRIBUTION;
            default:
                return QueryType.SUMMARY;
        }
    }
    
    private QueryConditions buildQueryConditions(List<Entity> entities, Map<String, Object> context) {
        QueryConditions conditions = new QueryConditions();
        
        // å¤„ç†æ—¶é—´å®ä½“
        Entity timeEntity = entities.stream()
            .filter(e -> "time".equals(e.getType()))
            .findFirst()
            .orElse(null);
        
        if (timeEntity != null) {
            TimeRange timeRange = parseTimeEntity(timeEntity);
            conditions.setTimeRange(timeRange);
        }
        
        // å¤„ç†ç»´åº¦å®ä½“
        List<Entity> dimensionEntities = entities.stream()
            .filter(e -> "dimension".equals(e.getType()))
            .collect(Collectors.toList());
        
        for (Entity entity : dimensionEntities) {
            DimensionFilter filter = parseDimensionEntity(entity);
            conditions.addDimensionFilter(filter);
        }
        
        // åº”ç”¨ä¸Šä¸‹æ–‡è¿‡æ»¤
        applyContextFilters(conditions, context);
        
        return conditions;
    }
    
    private TimeRange parseTimeEntity(Entity timeEntity) {
        String value = timeEntity.getValue();
        
        // è§£æç›¸å¯¹æ—¶é—´
        if (value.contains("æœ€è¿‘") || value.contains("last")) {
            return parseRelativeTime(value);
        }
        
        // è§£æç»å¯¹æ—¶é—´
        if (value.contains("åˆ°") || value.contains("to")) {
            return parseAbsoluteTimeRange(value);
        }
        
        // è§£æå•ä¸ªæ—¶é—´ç‚¹
        return parseSingleTime(value);
    }
    
    /**
     * æ‰§è¡ŒæŸ¥è¯¢è®¡åˆ’
     */
    public QueryResult executeQuery(PlannedQuery plannedQuery) {
        // è½¬æ¢ä¸ºSQLæŸ¥è¯¢
        String sqlQuery = translateToSQL(plannedQuery);
        
        // æ‰§è¡ŒæŸ¥è¯¢
        List<Map<String, Object>> rawData = queryExecutor.execute(sqlQuery);
        
        // åå¤„ç†ç»“æœ
        QueryResult result = postProcessResult(rawData, plannedQuery);
        
        return result;
    }
    
    private String translateToSQL(PlannedQuery plannedQuery) {
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT ");
        
        // æ·»åŠ é€‰æ‹©å­—æ®µ
        QuerySchema schema = plannedQuery.getSchema();
        sql.append(String.join(", ", schema.getMetrics()));
        
        // æ·»åŠ ç»´åº¦å­—æ®µ
        if (!schema.getDimensions().isEmpty()) {
            sql.append(", ").append(String.join(", ", schema.getDimensions()));
        }
        
        sql.append(" FROM ").append(schema.getDataSource());
        
        // æ·»åŠ è¿‡æ»¤æ¡ä»¶
        QueryConditions conditions = plannedQuery.getConditions();
        List<String> whereClauses = new ArrayList<>();
        
        // æ—¶é—´è¿‡æ»¤
        if (conditions.getTimeRange() != null) {
            whereClauses.add(buildTimeFilter(conditions.getTimeRange()));
        }
        
        // ç»´åº¦è¿‡æ»¤
        for (DimensionFilter filter : conditions.getDimensionFilters()) {
            whereClauses.add(buildDimensionFilter(filter));
        }
        
        if (!whereClauses.isEmpty()) {
            sql.append(" WHERE ").append(String.join(" AND ", whereClauses));
        }
        
        // æ·»åŠ åˆ†ç»„
        if (!schema.getDimensions().isEmpty()) {
            sql.append(" GROUP BY ").append(String.join(", ", schema.getDimensions()));
        }
        
        // æ·»åŠ æ’åº
        if (plannedQuery.getQueryType() == QueryType.RANKING) {
            sql.append(" ORDER BY ").append(schema.getMetrics().get(0)).append(" DESC");
        }
        
        return sql.toString();
    }
}
```

## è¯­éŸ³äº¤äº’æŠ€æœ¯å®ç°

### 3.1 è¯­éŸ³è¯†åˆ«é›†æˆ

#### 3.1.1 è¯­éŸ³è¯†åˆ«æœåŠ¡

```javascript
class VoiceRecognitionService {
    constructor() {
        this.recognition = null;
        this.isListening = false;
        this.supported = this.checkSupport();
    }
    
    checkSupport() {
        return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
    }
    
    initialize() {
        if (!this.supported) {
            throw new Error('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
        }
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        this.recognition = new SpeechRecognition();
        
        // é…ç½®è¯­éŸ³è¯†åˆ«
        this.recognition.continuous = false;  // å•æ¬¡è¯†åˆ«
        this.recognition.interimResults = true;  // è·å–ä¸­é—´ç»“æœ
        this.recognition.lang = 'zh-CN';  // è®¾ç½®è¯­è¨€
        this.recognition.maxAlternatives = 1;  // è¿”å›ä¸€ä¸ªæœ€ä½³ç»“æœ
        
        // ç»‘å®šäº‹ä»¶å¤„ç†å™¨
        this.bindEventHandlers();
    }
    
    bindEventHandlers() {
        this.recognition.onstart = () => {
            this.isListening = true;
            this.onListeningStart();
        };
        
        this.recognition.onresult = (event) => {
            const result = event.results[0];
            const transcript = result[0].transcript;
            const confidence = result[0].confidence;
            
            this.onSpeechResult(transcript, confidence, result.isFinal);
        };
        
        this.recognition.onerror = (event) => {
            this.isListening = false;
            this.onSpeechError(event.error);
        };
        
        this.recognition.onend = () => {
            this.isListening = false;
            this.onListeningEnd();
        };
    }
    
    startListening() {
        if (!this.recognition) {
            this.initialize();
        }
        
        if (!this.isListening) {
            this.recognition.start();
        }
    }
    
    stopListening() {
        if (this.isListening) {
            this.recognition.stop();
        }
    }
    
    // äº‹ä»¶å›è°ƒæ–¹æ³•ï¼ˆéœ€è¦è¢«å­ç±»é‡å†™ï¼‰
    onListeningStart() {
        console.log('å¼€å§‹è¯­éŸ³è¯†åˆ«');
    }
    
    onSpeechResult(transcript, confidence, isFinal) {
        console.log('è¯†åˆ«ç»“æœ:', transcript, 'ç½®ä¿¡åº¦:', confidence, 'æ˜¯å¦æœ€ç»ˆç»“æœ:', isFinal);
    }
    
    onSpeechError(error) {
        console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', error);
    }
    
    onListeningEnd() {
        console.log('è¯­éŸ³è¯†åˆ«ç»“æŸ');
    }
}
```

#### 3.1.2 è¯­éŸ³äº¤äº’ç•Œé¢

```html
<!-- è¯­éŸ³äº¤äº’ç•Œé¢ -->
<div class="voice-interaction-panel">
    <div class="voice-header">
        <h3>è¯­éŸ³æŸ¥è¯¢</h3>
        <div class="voice-status" id="voiceStatus">
            <span class="status-indicator"></span>
            <span class="status-text">å‡†å¤‡å°±ç»ª</span>
        </div>
    </div>
    
    <div class="voice-content">
        <div class="voice-visualization">
            <canvas id="voiceVisualization" width="300" height="100"></canvas>
        </div>
        
        <div class="voice-input-area">
            <div class="transcript-display" id="transcriptDisplay">
                <div class="placeholder">ç‚¹å‡»éº¦å…‹é£å¼€å§‹è¯´è¯...</div>
                <div class="transcript-text"></div>
            </div>
            
            <div class="voice-controls">
                <button class="voice-btn" id="startVoiceBtn">
                    <span class="mic-icon">ğŸ¤</span>
                    <span class="btn-text">å¼€å§‹è¯´è¯</span>
                </button>
                
                <button class="voice-btn stop-btn" id="stopVoiceBtn" style="display: none;">
                    <span class="stop-icon">â¹ï¸</span>
                    <span class="btn-text">åœæ­¢</span>
                </button>
            </div>
        </div>
    </div>
    
    <div class="voice-results" id="voiceResults" style="display: none;">
        <div class="result-header">
            <h4>æŸ¥è¯¢ç»“æœ</h4>
            <button class="close-btn" id="closeResultsBtn">Ã—</button>
        </div>
        <div class="result-content"></div>
    </div>
</div>

<script>
class VoiceQueryInterface extends VoiceRecognitionService {
    constructor() {
        super();
        this.initializeUI();
        this.audioContext = null;
        this.analyzer = null;
    }
    
    initializeUI() {
        this.voiceStatus = document.getElementById('voiceStatus');
        this.transcriptDisplay = document.getElementById('transcriptDisplay');
        this.startVoiceBtn = document.getElementById('startVoiceBtn');
        this.stopVoiceBtn = document.getElementById('stopVoiceBtn');
        this.voiceResults = document.getElementById('voiceResults');
        this.resultContent = document.querySelector('.result-content');
        
        // ç»‘å®šUIäº‹ä»¶
        this.startVoiceBtn.addEventListener('click', () => this.startVoiceQuery());
        this.stopVoiceBtn.addEventListener('click', () => this.stopVoiceQuery());
        document.getElementById('closeResultsBtn').addEventListener('click', () => {
            this.voiceResults.style.display = 'none';
        });
        
        // åˆå§‹åŒ–å¯è§†åŒ–ç”»å¸ƒ
        this.initVisualization();
    }
    
    initVisualization() {
        this.canvas = document.getElementById('voiceVisualization');
        this.ctx = this.canvas.getContext('2d');
        
        // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡ç”¨äºå¯è§†åŒ–
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.analyzer = this.audioContext.createAnalyser();
            this.analyzer.fftSize = 256;
        } catch (e) {
            console.warn('æ— æ³•åˆå§‹åŒ–éŸ³é¢‘å¯è§†åŒ–:', e);
        }
    }
    
    startVoiceQuery() {
        try {
            this.startListening();
            this.updateStatus('listening', 'æ­£åœ¨è†å¬...');
            this.startVoiceBtn.style.display = 'none';
            this.stopVoiceBtn.style.display = 'inline-flex';
            this.clearTranscript();
        } catch (error) {
            this.updateStatus('error', 'è¯­éŸ³è¯†åˆ«åˆå§‹åŒ–å¤±è´¥');
            console.error('è¯­éŸ³æŸ¥è¯¢å¯åŠ¨å¤±è´¥:', error);
        }
    }
    
    stopVoiceQuery() {
        this.stopListening();
        this.updateStatus('ready', 'å‡†å¤‡å°±ç»ª');
        this.startVoiceBtn.style.display = 'inline-flex';
        this.stopVoiceBtn.style.display = 'none';
    }
    
    onListeningStart() {
        this.updateStatus('listening', 'æ­£åœ¨è†å¬...');
        this.startVisualization();
    }
    
    onSpeechResult(transcript, confidence, isFinal) {
        this.updateTranscript(transcript, confidence);
        
        if (isFinal) {
            this.processVoiceQuery(transcript);
        }
    }
    
    onSpeechError(error) {
        this.updateStatus('error', `è¯†åˆ«é”™è¯¯: ${error}`);
        this.stopVoiceQuery();
    }
    
    onListeningEnd() {
        this.updateStatus('ready', 'å‡†å¤‡å°±ç»ª');
        this.stopVoiceQuery();
        this.stopVisualization();
    }
    
    updateStatus(status, text) {
        const statusIndicator = this.voiceStatus.querySelector('.status-indicator');
        const statusText = this.voiceStatus.querySelector('.status-text');
        
        statusIndicator.className = 'status-indicator ' + status;
        statusText.textContent = text;
    }
    
    updateTranscript(transcript, confidence) {
        const transcriptText = this.transcriptDisplay.querySelector('.transcript-text');
        const placeholder = this.transcriptDisplay.querySelector('.placeholder');
        
        if (transcript) {
            placeholder.style.display = 'none';
            transcriptText.textContent = transcript;
            transcriptText.style.opacity = confidence;
        } else {
            placeholder.style.display = 'block';
            transcriptText.textContent = '';
        }
    }
    
    clearTranscript() {
        const transcriptText = this.transcriptDisplay.querySelector('.transcript-text');
        const placeholder = this.transcriptDisplay.querySelector('.placeholder');
        
        placeholder.style.display = 'block';
        transcriptText.textContent = '';
    }
    
    async processVoiceQuery(queryText) {
        try {
            this.updateStatus('processing', 'æ­£åœ¨å¤„ç†æŸ¥è¯¢...');
            
            // å‘é€åˆ°åç«¯å¤„ç†
            const response = await fetch('/api/v1/nlq/query', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query: queryText,
                    type: 'voice'
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.displayResults(result.data);
                this.speakResults(result.data);
            } else {
                throw new Error(result.message);
            }
            
        } catch (error) {
            this.updateStatus('error', `æŸ¥è¯¢å¤±è´¥: ${error.message}`);
            console.error('è¯­éŸ³æŸ¥è¯¢å¤„ç†å¤±è´¥:', error);
        }
    }
    
    displayResults(data) {
        this.voiceResults.style.display = 'block';
        
        let html = '<div class="result-summary">';
        
        if (data.type === 'metric') {
            html += `
                <div class="metric-result">
                    <div class="metric-value">${data.value}</div>
                    <div class="metric-label">${data.label}</div>
                    <div class="metric-context">${data.context || ''}</div>
                </div>
            `;
        } else if (data.type === 'list') {
            html += '<ul class="result-list">';
            data.items.forEach(item => {
                html += `<li>${item.label}: ${item.value}</li>`;
            });
            html += '</ul>';
        } else if (data.type === 'table') {
            html += '<table class="result-table">';
            html += '<thead><tr>';
            data.columns.forEach(col => {
                html += `<th>${col}</th>`;
            });
            html += '</tr></thead>';
            html += '<tbody>';
            data.rows.forEach(row => {
                html += '<tr>';
                row.forEach(cell => {
                    html += `<td>${cell}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
        }
        
        html += '</div>';
        
        this.resultContent.innerHTML = html;
    }
    
    speakResults(data) {
        // ä½¿ç”¨è¯­éŸ³åˆæˆæœ—è¯»ç»“æœ
        if ('speechSynthesis' in window) {
            let textToSpeak = '';
            
            if (data.type === 'metric') {
                textToSpeak = `æŸ¥è¯¢ç»“æœï¼š${data.label}ä¸º${data.value}`;
            } else if (data.type === 'list') {
                textToSpeak = 'æŸ¥è¯¢ç»“æœï¼š';
                data.items.forEach((item, index) => {
                    textToSpeak += `${item.label}ä¸º${item.value}ï¼Œ`;
                });
            }
            
            if (textToSpeak) {
                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                utterance.lang = 'zh-CN';
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                speechSynthesis.speak(utterance);
            }
        }
    }
    
    startVisualization() {
        if (!this.analyzer) return;
        
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…å®ç°éœ€è¦è¿æ¥éº¦å…‹é£è¾“å…¥
        this.visualizationInterval = setInterval(() => {
            this.drawVisualization();
        }, 100);
    }
    
    stopVisualization() {
        if (this.visualizationInterval) {
            clearInterval(this.visualizationInterval);
            this.visualizationInterval = null;
        }
        
        // æ¸…ç©ºç”»å¸ƒ
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    drawVisualization() {
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // æ¸…ç©ºç”»å¸ƒ
        this.ctx.clearRect(0, 0, width, height);
        
        // ç»˜åˆ¶éŸ³é¢‘å¯è§†åŒ–æ•ˆæœ
        this.ctx.fillStyle = '#4CAF50';
        
        // æ¨¡æ‹ŸéŸ³é¢‘æ•°æ®ï¼ˆå®é™…åº”è¯¥ä»éŸ³é¢‘åˆ†æå™¨è·å–ï¼‰
        const barCount = 32;
        const barWidth = width / barCount;
        
        for (let i = 0; i < barCount; i++) {
            const barHeight = Math.random() * height;
            this.ctx.fillRect(i * barWidth, height - barHeight, barWidth - 2, barHeight);
        }
    }
}

// åˆå§‹åŒ–è¯­éŸ³æŸ¥è¯¢ç•Œé¢
document.addEventListener('DOMContentLoaded', () => {
    const voiceInterface = new VoiceQueryInterface();
    
    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
    if (!voiceInterface.supported) {
        document.getElementById('voiceStatus').innerHTML = 
            '<span class="status-indicator error"></span><span class="status-text">æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«</span>';
        document.getElementById('startVoiceBtn').disabled = true;
    }
});
</script>
```

### 3.2 è¯­éŸ³åˆæˆæœåŠ¡

```go
package voice

import (
    "context"
    "fmt"
    "strings"
    "time"
    
    "cloud.google.com/go/texttospeech/apiv1"
    texttospeechpb "google.golang.org/genproto/googleapis/cloud/texttospeech/v1"
)

type VoiceSynthesisService struct {
    client *texttospeech.Client
    config *SynthesisConfig
}

type SynthesisConfig struct {
    LanguageCode string
    VoiceName    string
    AudioConfig  *texttospeechpb.AudioConfig
}

type SynthesisResult struct {
    AudioContent []byte
    AudioFormat  string
    Duration     time.Duration
}

func NewVoiceSynthesisService(ctx context.Context, config *SynthesisConfig) (*VoiceSynthesisService, error) {
    client, err := texttospeech.NewClient(ctx)
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºè¯­éŸ³åˆæˆå®¢æˆ·ç«¯å¤±è´¥: %v", err)
    }
    
    return &VoiceSynthesisService{
        client: client,
        config: config,
    }, nil
}

func (v *VoiceSynthesisService) SynthesizeText(ctx context.Context, text string) (*SynthesisResult, error) {
    // æ„å»ºåˆæˆè¯·æ±‚
    req := &texttospeechpb.SynthesizeSpeechRequest{
        Input: &texttospeechpb.SynthesisInput{
            InputSource: &texttospeechpb.SynthesisInput_Text{
                Text: text,
            },
        },
        Voice: &texttospeechpb.VoiceSelectionParams{
            LanguageCode: v.config.LanguageCode,
            Name:         v.config.VoiceName,
        },
        AudioConfig: v.config.AudioConfig,
    }
    
    // æ‰§è¡Œåˆæˆ
    resp, err := v.client.SynthesizeSpeech(ctx, req)
    if err != nil {
        return nil, fmt.Errorf("è¯­éŸ³åˆæˆå¤±è´¥: %v", err)
    }
    
    // è®¡ç®—éŸ³é¢‘æ—¶é•¿ï¼ˆç®€åŒ–ä¼°ç®—ï¼‰
    duration := time.Duration(len(text)) * time.Millisecond * 100
    
    return &SynthesisResult{
        AudioContent: resp.AudioContent,
        AudioFormat:  "mp3", // å‡è®¾ä½¿ç”¨MP3æ ¼å¼
        Duration:     duration,
    }, nil
}

func (v *VoiceSynthesisService) SynthesizeQueryResult(ctx context.Context, result interface{}) (*SynthesisResult, error) {
    // å°†æŸ¥è¯¢ç»“æœè½¬æ¢ä¸ºè‡ªç„¶è¯­è¨€
    text, err := v.formatResultAsText(result)
    if err != nil {
        return nil, fmt.Errorf("æ ¼å¼åŒ–ç»“æœå¤±è´¥: %v", err)
    }
    
    // æ‰§è¡Œè¯­éŸ³åˆæˆ
    return v.SynthesizeText(ctx, text)
}

func (v *VoiceSynthesisService) formatResultAsText(result interface{}) (string, error) {
    // æ ¹æ®ç»“æœç±»å‹æ ¼å¼åŒ–ä¸ºè‡ªç„¶è¯­è¨€
    switch res := result.(type) {
    case map[string]interface{}:
        return v.formatMapResult(res)
    case []interface{}:
        return v.formatListResult(res)
    default:
        return fmt.Sprintf("æŸ¥è¯¢ç»“æœ: %v", result), nil
    }
}

func (v *VoiceSynthesisService) formatMapResult(result map[string]interface{}) (string, error) {
    if metric, ok := result["metric"]; ok {
        value := result["value"]
        label := result["label"]
        return fmt.Sprintf("æŸ¥è¯¢ç»“æœï¼š%sä¸º%s", label, value), nil
    }
    
    // é€šç”¨æ ¼å¼åŒ–
    var parts []string
    for key, value := range result {
        parts = append(parts, fmt.Sprintf("%sä¸º%v", key, value))
    }
    
    return "æŸ¥è¯¢ç»“æœï¼š" + strings.Join(parts, "ï¼Œ"), nil
}

func (v *VoiceSynthesisService) formatListResult(result []interface{}) (string, error) {
    if len(result) == 0 {
        return "æ²¡æœ‰æŸ¥è¯¢åˆ°ç›¸å…³ç»“æœ", nil
    }
    
    var parts []string
    for i, item := range result {
        if i >= 5 { // é™åˆ¶æœ—è¯»æ•°é‡
            parts = append(parts, "ç­‰")
            break
        }
        
        switch item := item.(type) {
        case map[string]interface{}:
            if label, ok := item["label"]; ok {
                if value, ok := item["value"]; ok {
                    parts = append(parts, fmt.Sprintf("%sä¸º%v", label, value))
                }
            }
        default:
            parts = append(parts, fmt.Sprintf("ç¬¬%dé¡¹ä¸º%v", i+1, item))
        }
    }
    
    return "æŸ¥è¯¢ç»“æœï¼š" + strings.Join(parts, "ï¼Œ"), nil
}
```

## æ™ºèƒ½é—®ç­”ç³»ç»Ÿ

### 4.1 é—®ç­”å¼•æ“è®¾è®¡

#### 4.1.1 å¯¹è¯ç®¡ç†

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::sync::RwLock;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ConversationContext {
    pub session_id: String,
    pub user_id: String,
    pub history: Vec<DialogTurn>,
    pub current_state: DialogState,
    pub entities: HashMap<String, String>,
    pub preferences: UserPreferences,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DialogTurn {
    pub turn_id: String,
    pub user_input: String,
    pub system_response: String,
    pub intent: String,
    pub entities: HashMap<String, String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum DialogState {
    Initial,
    Clarifying,
    Executing,
    FollowUp,
    Completed,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UserPreferences {
    pub language: String,
    pub voice_enabled: bool,
    pub detail_level: DetailLevel,
    pub favorite_metrics: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum DetailLevel {
    Summary,
    Detailed,
    Comprehensive,
}

pub struct DialogManager {
    contexts: RwLock<HashMap<String, ConversationContext>>,
    nlu_engine: NluEngine,
    query_executor: QueryExecutor,
    response_generator: ResponseGenerator,
}

impl DialogManager {
    pub fn new(
        nlu_engine: NluEngine,
        query_executor: QueryExecutor,
        response_generator: ResponseGenerator,
    ) -> Self {
        Self {
            contexts: RwLock::new(HashMap::new()),
            nlu_engine,
            query_executor,
            response_generator,
        }
    }
    
    pub async fn process_user_input(
        &self,
        session_id: &str,
        user_id: &str,
        user_input: &str,
    ) -> Result<String, Box<dyn std::error::Error>> {
        // è·å–æˆ–åˆ›å»ºå¯¹è¯ä¸Šä¸‹æ–‡
        let mut context = self.get_or_create_context(session_id, user_id).await?;
        
        // ç†è§£ç”¨æˆ·è¾“å…¥
        let nlu_result = self.nlu_engine.understand(user_input, &context).await?;
        
        // æ ¹æ®å¯¹è¯çŠ¶æ€å¤„ç†
        let response = match context.current_state {
            DialogState::Initial => {
                self.handle_initial_state(&mut context, &nlu_result).await?
            }
            DialogState::Clarifying => {
                self.handle_clarifying_state(&mut context, &nlu_result).await?
            }
            DialogState::Executing => {
                self.handle_executing_state(&mut context, &nlu_result).await?
            }
            DialogState::FollowUp => {
                self.handle_follow_up_state(&mut context, &nlu_result).await?
            }
            DialogState::Completed => {
                self.handle_completed_state(&mut context, &nlu_result).await?
            }
        };
        
        // æ›´æ–°å¯¹è¯å†å²
        self.update_conversation_history(&mut context, user_input, &response, &nlu_result).await?;
        
        // ä¿å­˜ä¸Šä¸‹æ–‡
        self.save_context(session_id, context).await?;
        
        Ok(response)
    }
    
    async fn handle_initial_state(
        &self,
        context: &mut ConversationContext,
        nlu_result: &NluResult,
    ) -> Result<String, Box<dyn std::error::Error>> {
        match &nlu_result.intent[..] {
            "query_metric" => {
                // ç›´æ¥æ‰§è¡ŒæŸ¥è¯¢
                context.current_state = DialogState::Executing;
                self.execute_query(context, nlu_result).await
            }
            "exploratory_question" => {
                // éœ€è¦æ¾„æ¸…çš„æ¢ç´¢æ€§é—®é¢˜
                context.current_state = DialogState::Clarifying;
                self.ask_clarifying_questions(context, nlu_result).await
            }
            "greeting" => {
                self.response_generator.generate_greeting_response(context).await
            }
            _ => {
                self.response_generator.generate_help_response(context).await
            }
        }
    }
    
    async fn handle_clarifying_state(
        &self,
        context: &mut ConversationContext,
        nlu_result: &NluResult,
    ) -> Result<String, Box<dyn std::error::Error>> {
        // æ”¶é›†æ¾„æ¸…ä¿¡æ¯
        self.collect_clarification_info(context, nlu_result).await?;
        
        // æ£€æŸ¥æ˜¯å¦æ”¶é›†äº†è¶³å¤Ÿä¿¡æ¯
        if self.has_sufficient_info(context) {
            context.current_state = DialogState::Executing;
            self.execute_query(context, nlu_result).await
        } else {
            // ç»§ç»­è¯¢é—®
            self.ask_clarifying_questions(context, nlu_result).await
        }
    }
    
    async fn execute_query(
        &self,
        context: &mut ConversationContext,
        nlu_result: &NluResult,
    ) -> Result<String, Box<dyn std::error::Error>> {
        // æ‰§è¡ŒæŸ¥è¯¢
        let query_result = self.query_executor.execute(nlu_result).await?;
        
        // ç”Ÿæˆå“åº”
        let response = self.response_generator.generate_query_response(
            &query_result,
            &context.preferences,
        ).await?;
        
        // è®¾ç½®åç»­çŠ¶æ€
        context.current_state = DialogState::FollowUp;
        
        Ok(response)
    }
    
    async fn ask_clarifying_questions(
        &self,
        context: &ConversationContext,
        nlu_result: &NluResult,
    ) -> Result<String, Box<dyn std::error::Error>> {
        // åŸºäºå½“å‰æ”¶é›†çš„ä¿¡æ¯ç”Ÿæˆæ¾„æ¸…é—®é¢˜
        let missing_info = self.identify_missing_info(context, nlu_result);
        let questions = self.generate_clarification_questions(&missing_info);
        
        Ok(questions.join("\n"))
    }
}
```

#### 4.1.2 å“åº”ç”Ÿæˆ

```python
class ResponseGenerator:
    def __init__(self, template_manager, voice_service=None):
        self.template_manager = template_manager
        self.voice_service = voice_service
        self.response_cache = {}
    
    async def generate_query_response(self, query_result, user_preferences):
        """
        ç”ŸæˆæŸ¥è¯¢ç»“æœå“åº”
        """
        # ç”Ÿæˆæ–‡æœ¬å“åº”
        text_response = self.generate_text_response(query_result, user_preferences)
        
        # å¦‚æœå¯ç”¨è¯­éŸ³ï¼Œç”Ÿæˆè¯­éŸ³å“åº”
        voice_response = None
        if user_preferences.get('voice_enabled', False) and self.voice_service:
            voice_response = await self.voice_service.synthesize(text_response)
        
        return {
            'text': text_response,
            'voice': voice_response,
            'type': 'query_result',
            'data': query_result
        }
    
    def generate_text_response(self, query_result, user_preferences):
        """
        ç”Ÿæˆæ–‡æœ¬å“åº”
        """
        detail_level = user_preferences.get('detail_level', 'summary')
        
        if query_result['type'] == 'metric':
            return self.generate_metric_response(query_result, detail_level)
        elif query_result['type'] == 'trend':
            return self.generate_trend_response(query_result, detail_level)
        elif query_result['type'] == 'comparison':
            return self.generate_comparison_response(query_result, detail_level)
        elif query_result['type'] == 'ranking':
            return self.generate_ranking_response(query_result, detail_level)
        else:
            return self.generate_generic_response(query_result, detail_level)
    
    def generate_metric_response(self, result, detail_level):
        """
        ç”ŸæˆæŒ‡æ ‡æŸ¥è¯¢å“åº”
        """
        metric_name = result.get('metric_name', 'æœªçŸ¥æŒ‡æ ‡')
        value = result.get('value', 'æ— æ•°æ®')
        unit = result.get('unit', '')
        context = result.get('context', '')
        
        if detail_level == 'summary':
            return f"æŸ¥è¯¢ç»“æœï¼š{metric_name}{context}ä¸º{value}{unit}"
        elif detail_level == 'detailed':
            trend = result.get('trend', '')
            comparison = result.get('comparison', '')
            
            response = f"æŸ¥è¯¢ç»“æœï¼š{metric_name}{context}ä¸º{value}{unit}"
            if trend:
                response += f"ï¼Œ{trend}"
            if comparison:
                response += f"ï¼Œ{comparison}"
            
            return response
        else:  # comprehensive
            response = f"è¯¦ç»†æŸ¥è¯¢ç»“æœï¼š\n"
            response += f"æŒ‡æ ‡åç§°ï¼š{metric_name}\n"
            response += f"å½“å‰å€¼ï¼š{value}{unit}\n"
            response += f"æ—¶é—´èŒƒå›´ï¼š{result.get('time_range', 'æœ€è¿‘')}\n"
            
            if 'trend' in result:
                response += f"è¶‹åŠ¿åˆ†æï¼š{result['trend']}\n"
            if 'comparison' in result:
                response += f"å¯¹æ¯”åˆ†æï¼š{result['comparison']}\n"
            if 'insights' in result:
                response += f"æ´å¯Ÿå»ºè®®ï¼š{result['insights']}\n"
            
            return response
    
    def generate_trend_response(self, result, detail_level):
        """
        ç”Ÿæˆè¶‹åŠ¿æŸ¥è¯¢å“åº”
        """
        metric_name = result.get('metric_name', 'æœªçŸ¥æŒ‡æ ‡')
        
        if detail_level == 'summary':
            return f"{metric_name}çš„æ•´ä½“è¶‹åŠ¿æ˜¯{result.get('overall_trend', 'ç¨³å®š')}"
        elif detail_level == 'detailed':
            periods = result.get('periods', [])
            if periods:
                latest_period = periods[-1]
                return f"{metric_name}åœ¨{latest_period.get('period', 'è¿‘æœŸ')}çš„è¶‹åŠ¿æ˜¯{latest_period.get('trend', 'ç¨³å®š')}"
            else:
                return f"{metric_name}çš„è¶‹åŠ¿åˆ†æå®Œæˆ"
        else:  # comprehensive
            response = f"{metric_name}çš„è¯¦ç»†è¶‹åŠ¿åˆ†æï¼š\n"
            for period in result.get('periods', []):
                response += f"- {period.get('period', '')}: {period.get('value', '')} ({period.get('trend', '')})\n"
            return response
    
    async def generate_follow_up_response(self, original_query, user_input):
        """
        ç”Ÿæˆåç»­é—®é¢˜å“åº”
        """
        # åˆ†æç”¨æˆ·åç»­é—®é¢˜çš„æ„å›¾
        intent = self.analyze_follow_up_intent(user_input)
        
        if intent == 'clarification':
            return "è¯·æä¾›æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œæ¯”å¦‚å…·ä½“çš„æ—¶é—´èŒƒå›´æˆ–ç»´åº¦"
        elif intent == 'related_query':
            # ç”Ÿæˆç›¸å…³æŸ¥è¯¢
            related_result = await self.execute_related_query(original_query, user_input)
            return self.generate_text_response(related_result, {'detail_level': 'detailed'})
        elif intent == 'visualization_request':
            return "æ­£åœ¨ä¸ºæ‚¨ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨ï¼Œè¯·ç¨å€™..."
        else:
            return "æˆ‘ç†è§£æ‚¨çš„é—®é¢˜ï¼Œæ­£åœ¨å¤„ç†ä¸­..."
    
    def analyze_follow_up_intent(self, user_input):
        """
        åˆ†æåç»­é—®é¢˜æ„å›¾
        """
        user_input = user_input.lower()
        
        if any(word in user_input for word in ['è¯¦ç»†', 'å…·ä½“', 'æ›´å¤š']):
            return 'clarification'
        elif any(word in user_input for word in ['å›¾è¡¨', 'å›¾', 'å¯è§†åŒ–']):
            return 'visualization_request'
        elif any(word in user_input for word in ['æ¯”è¾ƒ', 'å¯¹æ¯”', 'å˜åŒ–']):
            return 'related_query'
        else:
            return 'general'
```

## æ€§èƒ½ä¼˜åŒ–ä¸ç”¨æˆ·ä½“éªŒ

### 5.1 å“åº”é€Ÿåº¦ä¼˜åŒ–

#### 5.1.1 ç¼“å­˜ç­–ç•¥

```sql
-- è‡ªç„¶è¯­è¨€æŸ¥è¯¢ç¼“å­˜è¡¨
CREATE TABLE nlq_cache (
    id BIGSERIAL PRIMARY KEY,
    query_text TEXT NOT NULL,
    query_hash VARCHAR(64) NOT NULL UNIQUE,
    parsed_result JSONB,
    execution_plan JSONB,
    result_data JSONB,
    hit_count INTEGER DEFAULT 0,
    last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP
);

-- æŸ¥è¯¢ç¼“å­˜ç´¢å¼•
CREATE INDEX idx_nlq_cache_hash ON nlq_cache (query_hash);
CREATE INDEX idx_nlq_cache_accessed ON nlq_cache (last_accessed);
CREATE INDEX idx_nlq_cache_expires ON nlq_cache (expires_at);

-- çƒ­ç‚¹æŸ¥è¯¢ç»Ÿè®¡
CREATE TABLE nlq_hot_queries (
    query_pattern TEXT PRIMARY KEY,
    frequency INTEGER DEFAULT 1,
    last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    average_response_time DECIMAL(8,3),
    success_rate DECIMAL(5,4)
);
```

#### 5.1.2 é¢„å¤„ç†ä¼˜åŒ–

```java
@Component
public class NLQPreprocessor {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private HotQueryService hotQueryService;
    
    private final Map<String, PreprocessedQuery> localCache = new ConcurrentHashMap<>();
    private final int LOCAL_CACHE_SIZE = 1000;
    
    /**
     * é¢„å¤„ç†è‡ªç„¶è¯­è¨€æŸ¥è¯¢
     */
    public PreprocessedQuery preprocessQuery(String queryText) {
        // ç”ŸæˆæŸ¥è¯¢å“ˆå¸Œ
        String queryHash = generateQueryHash(queryText);
        
        // 1. æ£€æŸ¥æœ¬åœ°ç¼“å­˜
        PreprocessedQuery cached = localCache.get(queryHash);
        if (cached != null && !isExpired(cached)) {
            return cached;
        }
        
        // 2. æ£€æŸ¥Redisç¼“å­˜
        cached = (PreprocessedQuery) redisTemplate.opsForValue().get("nlq:preprocessed:" + queryHash);
        if (cached != null && !isExpired(cached)) {
            // å›å¡«æœ¬åœ°ç¼“å­˜
            addToLocalCache(queryHash, cached);
            return cached;
        }
        
        // 3. æ‰§è¡Œé¢„å¤„ç†
        PreprocessedQuery preprocessed = doPreprocess(queryText);
        
        // 4. ç¼“å­˜ç»“æœ
        cachePreprocessedQuery(queryHash, preprocessed);
        
        return preprocessed;
    }
    
    private PreprocessedQuery doPreprocess(String queryText) {
        PreprocessedQuery result = new PreprocessedQuery();
        result.setOriginalText(queryText);
        result.setProcessedText(preprocessText(queryText));
        result.setTokens(tokenizeText(result.getProcessedText()));
        result.setNormalizedText(normalizeText(result.getTokens()));
        result.setEntities(extractEntities(result.getNormalizedText()));
        result.setIntent(classifyIntent(result.getNormalizedText(), result.getEntities()));
        result.setTimestamp(System.currentTimeMillis());
        result.setExpiresAt(System.currentTimeMillis() + 3600000); // 1å°æ—¶è¿‡æœŸ
        
        return result;
    }
    
    private String preprocessText(String text) {
        // æ–‡æœ¬æ¸…ç†å’Œæ ‡å‡†åŒ–
        text = text.trim().toLowerCase();
        text = text.replaceAll("[^\\w\\s\\u4e00-\\u9fff]", " "); // ä¿ç•™ä¸­è‹±æ–‡å’Œæ•°å­—
        text = text.replaceAll("\\s+", " "); // åˆå¹¶å¤šä¸ªç©ºæ ¼
        
        return text;
    }
    
    private List<String> tokenizeText(String text) {
        // åˆ†è¯å¤„ç†ï¼ˆç®€åŒ–å®ç°ï¼‰
        return Arrays.asList(text.split("\\s+"));
    }
    
    private String normalizeText(List<String> tokens) {
        // åŒä¹‰è¯æ ‡å‡†åŒ–
        List<String> normalized = new ArrayList<>();
        for (String token : tokens) {
            normalized.add(normalizeToken(token));
        }
        return String.join(" ", normalized);
    }
    
    private String normalizeToken(String token) {
        // åŒä¹‰è¯æ˜ å°„
        Map<String, String> synonyms = Map.of(
            "æ”¶å…¥", "revenue",
            "ç”¨æˆ·", "user",
            "äº§å“", "product",
            "æœ€è¿‘", "last",
            "è¿™ä¸ªæœˆ", "this month"
        );
        
        return synonyms.getOrDefault(token, token);
    }
    
    private void cachePreprocessedQuery(String queryHash, PreprocessedQuery preprocessed) {
        // ç¼“å­˜åˆ°Redis
        redisTemplate.opsForValue().set(
            "nlq:preprocessed:" + queryHash, 
            preprocessed, 
            Duration.ofHours(1)
        );
        
        // ç¼“å­˜åˆ°æœ¬åœ°
        addToLocalCache(queryHash, preprocessed);
        
        // æ›´æ–°çƒ­ç‚¹æŸ¥è¯¢ç»Ÿè®¡
        hotQueryService.updateQueryStats(preprocessed.getNormalizedText());
    }
    
    private void addToLocalCache(String key, PreprocessedQuery value) {
        if (localCache.size() >= LOCAL_CACHE_SIZE) {
            // ç§»é™¤æœ€æ—§çš„ç¼“å­˜é¡¹
            Iterator<Map.Entry<String, PreprocessedQuery>> iterator = localCache.entrySet().iterator();
            if (iterator.hasNext()) {
                iterator.next();
                iterator.remove();
            }
        }
        localCache.put(key, value);
    }
}
```

### 5.2 ç”¨æˆ·ä½“éªŒä¼˜åŒ–

#### 5.2.1 æ™ºèƒ½æç¤ºç³»ç»Ÿ

```typescript
class IntelligentSuggestionService {
    private queryHistory: QueryHistory[];
    private commonPatterns: QueryPattern[];
    private userPreferences: UserPreferences;
    
    constructor() {
        this.queryHistory = [];
        this.commonPatterns = [];
        this.userPreferences = this.loadUserPreferences();
        this.initializeCommonPatterns();
    }
    
    getSuggestions(input: string, context?: QueryContext): Suggestion[] {
        const suggestions: Suggestion[] = [];
        
        // 1. åŸºäºè¾“å…¥çš„å®æ—¶å»ºè®®
        suggestions.push(...this.getRealTimeSuggestions(input));
        
        // 2. åŸºäºå†å²æŸ¥è¯¢çš„å»ºè®®
        suggestions.push(...this.getHistoricalSuggestions(input));
        
        // 3. åŸºäºä¸Šä¸‹æ–‡çš„å»ºè®®
        if (context) {
            suggestions.push(...this.getContextualSuggestions(input, context));
        }
        
        // 4. åŸºäºçƒ­é—¨æŸ¥è¯¢çš„å»ºè®®
        suggestions.push(...this.getPopularSuggestions(input));
        
        // å»é‡å’Œæ’åº
        return this.deduplicateAndRank(suggestions);
    }
    
    private getRealTimeSuggestions(input: string): Suggestion[] {
        const suggestions: Suggestion[] = [];
        
        // æ¨¡ç³ŠåŒ¹é…æŒ‡æ ‡åç§°
        const matchingMetrics = this.searchMetrics(input);
        matchingMetrics.forEach(metric => {
            suggestions.push({
                type: 'metric',
                text: `æŸ¥è¯¢${metric.displayName}æŒ‡æ ‡`,
                value: `æŸ¥è¯¢${metric.name}`,
                confidence: this.calculateConfidence(input, metric.name),
                category: 'æŒ‡æ ‡æŸ¥è¯¢'
            });
        });
        
        // åŒ¹é…æŸ¥è¯¢æ¨¡å¼
        const matchingPatterns = this.matchPatterns(input);
        matchingPatterns.forEach(pattern => {
            suggestions.push({
                type: 'pattern',
                text: pattern.suggestionText,
                value: pattern.queryTemplate,
                confidence: pattern.confidence,
                category: pattern.category
            });
        });
        
        return suggestions;
    }
    
    private getHistoricalSuggestions(input: string): Suggestion[] {
        const suggestions: Suggestion[] = [];
        
        // æŸ¥æ‰¾ç›¸ä¼¼çš„å†å²æŸ¥è¯¢
        const similarQueries = this.findSimilarQueries(input);
        similarQueries.forEach(query => {
            suggestions.push({
                type: 'history',
                text: query.displayText,
                value: query.rawQuery,
                confidence: query.similarity,
                category: 'å†å²æŸ¥è¯¢',
                metadata: {
                    lastUsed: query.timestamp,
                    usageCount: query.count
                }
            });
        });
        
        return suggestions;
    }
    
    private getContextualSuggestions(input: string, context: QueryContext): Suggestion[] {
        const suggestions: Suggestion[] = [];
        
        // åŸºäºå½“å‰ä¸Šä¸‹æ–‡çš„å»ºè®®
        if (context.currentMetric) {
            // ç›¸å…³æŒ‡æ ‡å»ºè®®
            const relatedMetrics = this.getRelatedMetrics(context.currentMetric);
            relatedMetrics.forEach(metric => {
                suggestions.push({
                    type: 'related_metric',
                    text: `æŸ¥çœ‹${metric.displayName}ç›¸å…³æ•°æ®`,
                    value: `æŸ¥è¯¢${metric.name}`,
                    confidence: 0.8,
                    category: 'ç›¸å…³æŸ¥è¯¢'
                });
            });
            
            // ç»´åº¦ä¸‹é’»å»ºè®®
            const drillDownDimensions = this.getDrillDownDimensions(context.currentMetric);
            drillDownDimensions.forEach(dimension => {
                suggestions.push({
                    type: 'drill_down',
                    text: `æŒ‰${dimension.displayName}ç»´åº¦åˆ†æ`,
                    value: `æŒ‰${dimension.name}åˆ†æ${context.currentMetric}`,
                    confidence: 0.7,
                    category: 'ç»´åº¦åˆ†æ'
                });
            });
        }
        
        return suggestions;
    }
    
    private getPopularSuggestions(input: string): Suggestion[] {
        const suggestions: Suggestion[] = [];
        
        // è·å–çƒ­é—¨æŸ¥è¯¢
        const popularQueries = this.getPopularQueries(input);
        popularQueries.forEach(query => {
            suggestions.push({
                type: 'popular',
                text: query.displayText,
                value: query.rawQuery,
                confidence: query.popularity,
                category: 'çƒ­é—¨æŸ¥è¯¢',
                metadata: {
                    usageCount: query.count,
                    trending: query.isTrending
                }
            });
        });
        
        return suggestions;
    }
    
    private deduplicateAndRank(suggestions: Suggestion[]): Suggestion[] {
        // å»é‡
        const uniqueSuggestions = new Map<string, Suggestion>();
        suggestions.forEach(suggestion => {
            const key = `${suggestion.type}:${suggestion.value}`;
            if (!uniqueSuggestions.has(key) || 
                uniqueSuggestions.get(key)!.confidence < suggestion.confidence) {
                uniqueSuggestions.set(key, suggestion);
            }
        });
        
        // æ’åº
        return Array.from(uniqueSuggestions.values())
            .sort((a, b) => {
                // é¦–å…ˆæŒ‰ç½®ä¿¡åº¦æ’åº
                if (b.confidence !== a.confidence) {
                    return b.confidence - a.confidence;
                }
                
                // ç„¶åæŒ‰ç±»å‹æ’åº
                const typePriority = {
                    'history': 4,
                    'popular': 3,
                    'related_metric': 2,
                    'metric': 1,
                    'pattern': 0
                };
                
                return (typePriority[b.type] || 0) - (typePriority[a.type] || 0);
            })
            .slice(0, 10); // é™åˆ¶è¿”å›æ•°é‡
    }
}
```

## å®æ–½æ¡ˆä¾‹ä¸æœ€ä½³å®è·µ

### 6.1 æ¡ˆä¾‹1ï¼šæŸé›¶å”®ä¼ä¸šçš„æ™ºèƒ½åˆ†æåŠ©æ‰‹

è¯¥ä¼ä¸šéƒ¨ç½²äº†åŸºäºè‡ªç„¶è¯­è¨€æŸ¥è¯¢çš„æ™ºèƒ½åˆ†æåŠ©æ‰‹ï¼š

1. **ä¸šåŠ¡åœºæ™¯**ï¼š
   - é”€å”®ç»ç†å¯ä»¥é€šè¿‡è¯­éŸ³è¯¢é—®"ä¸Šä¸ªæœˆååŒ—åœ°åŒºçš„é”€å”®é¢æ˜¯å¤šå°‘"
   - ç³»ç»Ÿè‡ªåŠ¨è§£ææŸ¥è¯¢å¹¶è¿”å›å‡†ç¡®æ•°æ®
   - æ”¯æŒåç»­é—®é¢˜å¦‚"ä¸å»å¹´åŒæœŸç›¸æ¯”å¦‚ä½•"

2. **æŠ€æœ¯å®ç°**ï¼š
   - é›†æˆä¼ä¸šå†…éƒ¨çš„æŒ‡æ ‡å­—å…¸å’Œç»´åº¦ä½“ç³»
   - å®ç°äº†ä¸­æ–‡è¯­éŸ³è¯†åˆ«å’Œè¯­ä¹‰ç†è§£
   - æä¾›äº†ä¸°å¯Œçš„å¯è§†åŒ–ç»“æœå±•ç¤º

3. **ä¸šåŠ¡ä»·å€¼**ï¼š
   - å°†æ•°æ®åˆ†ææ—¶é—´ä»å°æ—¶çº§ç¼©çŸ­åˆ°ç§’çº§
   - æé«˜äº†ä¸šåŠ¡äººå‘˜çš„æ•°æ®ä½¿ç”¨æ•ˆç‡
   - å‡å°‘äº†å¯¹ä¸“ä¸šåˆ†æå¸ˆçš„ä¾èµ–

### 6.2 æ¡ˆä¾‹2ï¼šæŸé‡‘èæœºæ„çš„é£æ§è¯­éŸ³æŸ¥è¯¢ç³»ç»Ÿ

è¯¥æœºæ„æ„å»ºäº†é¢å‘é£é™©ç®¡ç†äººå‘˜çš„è¯­éŸ³æŸ¥è¯¢ç³»ç»Ÿï¼š

1. **åº”ç”¨åœºæ™¯**ï¼š
   - é£æ§äººå‘˜å¯ä»¥è¯¢é—®"å½“å‰é«˜é£é™©å®¢æˆ·æ•°é‡"
   - ç³»ç»Ÿæ”¯æŒå¤æ‚çš„æ¡ä»¶æŸ¥è¯¢å¦‚"æŸ¥è¯¢è¿‡å»ä¸€å‘¨æ–°å¢çš„é«˜é£é™©å®¢æˆ·"
   - æä¾›é£é™©é¢„è­¦å’Œå¤„ç½®å»ºè®®

2. **å®‰å…¨ç‰¹æ€§**ï¼š
   - å®ç°äº†ä¸¥æ ¼çš„æ•°æ®æƒé™æ§åˆ¶
   - æ”¯æŒè¯­éŸ³èº«ä»½éªŒè¯
   - è®°å½•å®Œæ•´çš„æ“ä½œå®¡è®¡æ—¥å¿—

3. **æ€§èƒ½è¡¨ç°**ï¼š
   - 95%çš„æŸ¥è¯¢åœ¨3ç§’å†…è¿”å›ç»“æœ
   - æ”¯æŒå¹¶å‘ç”¨æˆ·æ•°è¾¾åˆ°1000+
   - è¯­éŸ³è¯†åˆ«å‡†ç¡®ç‡è¾¾åˆ°90%ä»¥ä¸Š

### 6.3 æœ€ä½³å®è·µæ€»ç»“

åŸºäºå¤šä¸ªå®æ–½æ¡ˆä¾‹ï¼Œæ€»ç»“å‡ºä»¥ä¸‹æœ€ä½³å®è·µï¼š

```yaml
æœ€ä½³å®è·µ:
  æŠ€æœ¯é€‰å‹:
    - é€‰æ‹©æˆç†Ÿçš„NLPå’Œè¯­éŸ³å¤„ç†æ¡†æ¶
    - è€ƒè™‘äº‘æœåŠ¡å’Œæœ¬åœ°éƒ¨ç½²çš„å¹³è¡¡
    - é¢„ç•™æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§
  æ•°æ®æ²»ç†:
    - å»ºç«‹å®Œå–„çš„æŒ‡æ ‡å’Œç»´åº¦ç®¡ç†ä½“ç³»
    - å®ç°æ•°æ®è¡€ç¼˜å’Œè´¨é‡ç›‘æ§
    - å»ºç«‹æŸ¥è¯¢æ—¥å¿—å’Œä½¿ç”¨ç»Ÿè®¡
  ç”¨æˆ·ä½“éªŒ:
    - æä¾›ç›´è§‚çš„äº¤äº’ç•Œé¢
    - å®ç°æ™ºèƒ½æç¤ºå’Œçº é”™åŠŸèƒ½
    - æ”¯æŒå¤šæ¨¡æ€äº¤äº’æ–¹å¼
  å®‰å…¨åˆè§„:
    - å®æ–½ä¸¥æ ¼çš„æ•°æ®è®¿é—®æ§åˆ¶
    - ä¿æŠ¤ç”¨æˆ·éšç§å’Œæ•°æ®å®‰å…¨
    - ç¬¦åˆç›¸å…³æ³•è§„è¦æ±‚
```

## å®æ–½å»ºè®®ä¸æ³¨æ„äº‹é¡¹

### 7.1 å®æ–½å»ºè®®

1. **åˆ†é˜¶æ®µå®æ–½**ï¼š
   - å…ˆå®ç°æ–‡æœ¬NLQåŠŸèƒ½
   - é€æ­¥æ·»åŠ è¯­éŸ³äº¤äº’èƒ½åŠ›
   - æŒç»­ä¼˜åŒ–å‡†ç¡®ç‡å’Œç”¨æˆ·ä½“éªŒ

2. **é¢†åŸŸå®šåˆ¶**ï¼š
   - é’ˆå¯¹å…·ä½“ä¸šåŠ¡åœºæ™¯è®­ç»ƒæ¨¡å‹
   - å»ºç«‹é¢†åŸŸç‰¹å®šçš„è¯æ±‡è¡¨å’Œæ¨¡å¼
   - æ”¶é›†å’Œæ ‡æ³¨é«˜è´¨é‡è®­ç»ƒæ•°æ®

3. **ç”¨æˆ·åŸ¹è®­**ï¼š
   - æä¾›ä½¿ç”¨æŒ‡å—å’Œæœ€ä½³å®è·µ
   - å»ºç«‹ç”¨æˆ·åé¦ˆæœºåˆ¶
   - å®šæœŸæ›´æ–°å’Œä¼˜åŒ–ç³»ç»Ÿ

### 7.2 æ³¨æ„äº‹é¡¹

1. **å‡†ç¡®æ€§ä¿éšœ**ï¼š
   - å»ºç«‹æŸ¥è¯¢å‡†ç¡®ç‡ç›‘æ§æœºåˆ¶
   - æä¾›ç”¨æˆ·çº é”™å’Œåé¦ˆæ¸ é“
   - å®šæœŸæ›´æ–°å’Œä¼˜åŒ–æ¨¡å‹

2. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - å®æ–½åˆç†çš„ç¼“å­˜ç­–ç•¥
   - ä¼˜åŒ–æŸ¥è¯¢æ‰§è¡Œè®¡åˆ’
   - ç›‘æ§ç³»ç»Ÿå“åº”æ—¶é—´å’Œèµ„æºä½¿ç”¨

3. **å®‰å…¨é˜²æŠ¤**ï¼š
   - å®æ–½è®¿é—®æ§åˆ¶å’Œèº«ä»½éªŒè¯
   - ä¿æŠ¤æ•æ„Ÿæ•°æ®å’Œéšç§ä¿¡æ¯
   - å»ºç«‹å®Œæ•´çš„å®¡è®¡æ—¥å¿—

## æ€»ç»“

è‡ªç„¶è¯­è¨€æŸ¥è¯¢ä¸è¯­éŸ³äº¤äº’æŠ€æœ¯ä¸ºä¼ä¸šçº§ç»Ÿä¸€åº¦é‡å¹³å°å¸¦æ¥äº†é©å‘½æ€§çš„ç”¨æˆ·ä½“éªŒæå‡ã€‚é€šè¿‡è®©æ™®é€šç”¨æˆ·èƒ½å¤Ÿç”¨æ—¥å¸¸è¯­è¨€ä¸æ•°æ®ç³»ç»Ÿäº¤äº’ï¼Œå¤§å¤§é™ä½äº†æ•°æ®åˆ†æçš„é—¨æ§›ï¼Œæé«˜äº†æ•°æ®é©±åŠ¨å†³ç­–çš„æ•ˆç‡ã€‚

åœ¨å®æ–½è¿‡ç¨‹ä¸­ï¼Œéœ€è¦å…³æ³¨ä»¥ä¸‹å‡ ä¸ªå…³é”®ç‚¹ï¼š

1. **æŠ€æœ¯æ¶æ„**ï¼šåˆç†è®¾è®¡NLUã€æŸ¥è¯¢è§„åˆ’å’Œæ‰§è¡Œçš„æ¶æ„
2. **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›ç›´è§‚æ˜“ç”¨çš„äº¤äº’ç•Œé¢å’Œæ™ºèƒ½æç¤º
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡ç¼“å­˜å’Œé¢„å¤„ç†æå‡å“åº”é€Ÿåº¦
4. **å‡†ç¡®æ€§ä¿éšœ**ï¼šå»ºç«‹ç›‘æ§å’Œä¼˜åŒ–æœºåˆ¶ç¡®ä¿æŸ¥è¯¢å‡†ç¡®ç‡
5. **å®‰å…¨åˆè§„**ï¼šå®æ–½ä¸¥æ ¼çš„æ•°æ®å®‰å…¨å’Œéšç§ä¿æŠ¤æªæ–½

é€šè¿‡ç³»ç»Ÿæ€§çš„æ–¹æ³•å’Œæœ€ä½³å®è·µï¼Œå¯ä»¥æ„å»ºå‡ºåŠŸèƒ½å¼ºå¤§ã€æ€§èƒ½ä¼˜å¼‚ã€å®‰å…¨å¯é çš„è‡ªç„¶è¯­è¨€æŸ¥è¯¢ä¸è¯­éŸ³äº¤äº’ç³»ç»Ÿï¼Œä¸ºä¼ä¸šçš„æ•°å­—åŒ–è½¬å‹æä¾›å¼ºæœ‰åŠ›çš„æ”¯æŒã€‚è¿™æ ‡å¿—ç€ç¬¬8ç« "å¯è§†åŒ–ã€æŠ¥è¡¨ä¸æ´å¯Ÿ"çš„å®Œæ•´å†…å®¹åˆ›ä½œå®Œæˆï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°†è¿›å…¥ç¬¬9ç« "åˆ†æä¸é¢„è­¦"çš„åˆ›ä½œã€‚